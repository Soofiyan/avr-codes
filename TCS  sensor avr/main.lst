   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	lcd_port_config
  13               	lcd_port_config:
  14               	.LFB6:
  15               		.file 1 "lcd.h"
   1:lcd.h         **** #define RS 3
   2:lcd.h         **** #define RW 5
   3:lcd.h         **** #define EN 7
   4:lcd.h         **** #define lcd_port PORTC
   5:lcd.h         **** 
   6:lcd.h         **** #define sbit(reg,bit)    reg |= (1<<bit)            // Macro defined for Setting a bit of any regis
   7:lcd.h         **** #define cbit(reg,bit)    reg &= ~(1<<bit)        // Macro defined for Clearing a bit of any registe
   8:lcd.h         **** 
   9:lcd.h         **** void init_ports();
  10:lcd.h         **** void lcd_port_config (void);
  11:lcd.h         **** void lcd_reset();
  12:lcd.h         **** void lcd_init();
  13:lcd.h         **** void lcd_wr_command(unsigned char);
  14:lcd.h         **** void lcd_wr_char(char);
  15:lcd.h         **** void lcd_line1();
  16:lcd.h         **** void lcd_line2();
  17:lcd.h         **** void lcd_string(char*);
  18:lcd.h         **** 
  19:lcd.h         **** unsigned int temp;
  20:lcd.h         **** unsigned int unit;
  21:lcd.h         **** unsigned int tens;
  22:lcd.h         **** unsigned int hundred;
  23:lcd.h         **** unsigned int thousand;
  24:lcd.h         **** unsigned int million;
  25:lcd.h         **** 
  26:lcd.h         **** //Function to configure LCD port
  27:lcd.h         **** void lcd_port_config (void)
  28:lcd.h         **** {
  16               		.loc 1 28 1 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  29:lcd.h         ****     DDRC = DDRC | 0xF0; //all the LCD pin's direction set as output
  22               		.loc 1 29 5 view .LVU1
  23               		.loc 1 29 12 is_stmt 0 view .LVU2
  24 0000 87B1      		in r24,0x7
  25               		.loc 1 29 10 view .LVU3
  26 0002 806F      		ori r24,lo8(-16)
  27 0004 87B9      		out 0x7,r24
  30:lcd.h         ****     DDRA |= 0xA8;
  28               		.loc 1 30 5 is_stmt 1 view .LVU4
  29               		.loc 1 30 10 is_stmt 0 view .LVU5
  30 0006 81B1      		in r24,0x1
  31 0008 886A      		ori r24,lo8(-88)
  32 000a 81B9      		out 0x1,r24
  31:lcd.h         ****     PORTC = PORTC & 0x0F; // all the LCD pins are set to logic 0 except PORTC 7
  33               		.loc 1 31 5 is_stmt 1 view .LVU6
  34               		.loc 1 31 13 is_stmt 0 view .LVU7
  35 000c 88B1      		in r24,0x8
  36               		.loc 1 31 19 view .LVU8
  37 000e 8F70      		andi r24,lo8(15)
  38               		.loc 1 31 11 view .LVU9
  39 0010 88B9      		out 0x8,r24
  32:lcd.h         ****     PORTA &= 0x57;
  40               		.loc 1 32 5 is_stmt 1 view .LVU10
  41               		.loc 1 32 11 is_stmt 0 view .LVU11
  42 0012 82B1      		in r24,0x2
  43 0014 8775      		andi r24,lo8(87)
  44 0016 82B9      		out 0x2,r24
  45               	/* epilogue start */
  33:lcd.h         **** }
  46               		.loc 1 33 1 view .LVU12
  47 0018 0895      		ret
  48               		.cfi_endproc
  49               	.LFE6:
  51               	.global	lcd_set_4bit
  53               	lcd_set_4bit:
  54               	.LFB7:
  34:lcd.h         **** 
  35:lcd.h         **** 
  36:lcd.h         **** 
  37:lcd.h         **** //Function to Reset LCD
  38:lcd.h         **** void lcd_set_4bit()
  39:lcd.h         **** {
  55               		.loc 1 39 1 is_stmt 1 view -0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  40:lcd.h         ****     _delay_ms(1);
  61               		.loc 1 40 5 view .LVU14
  62               	.LVL0:
  63               	.LBB36:
  64               	.LBI36:
  65               		.file 2 "/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** _delay_ms(double __ms)
  66               		.loc 2 166 1 view .LVU15
  67               	.LBB37:
 167:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	double __tmp ;
  68               		.loc 2 168 2 view .LVU16
 169:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
  69               		.loc 2 172 2 view .LVU17
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
  70               		.loc 2 173 2 view .LVU18
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
  71               		.loc 2 174 2 view .LVU19
 175:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
  72               		.loc 2 184 3 view .LVU20
 185:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  73               		.loc 2 187 2 view .LVU21
  74 001a 8FE9      		ldi r24,lo8(3999)
  75 001c 9FE0      		ldi r25,hi8(3999)
  76 001e 0197      	1:	sbiw r24,1
  77 0020 01F4      		brne 1b
  78 0022 00C0      		rjmp .
  79 0024 0000      		nop
  80               	.LVL1:
  81               		.loc 2 187 2 is_stmt 0 view .LVU22
  82               	.LBE37:
  83               	.LBE36:
  41:lcd.h         ****     
  42:lcd.h         ****     cbit(PORTA,RS);                //RS=0 --- Command Input
  84               		.loc 1 42 5 is_stmt 1 view .LVU23
  85 0026 1398      		cbi 0x2,3
  43:lcd.h         ****     cbit(PORTA,RW);                //RW=0 --- Writing to LCD
  86               		.loc 1 43 5 view .LVU24
  87 0028 1598      		cbi 0x2,5
  44:lcd.h         ****     lcd_port = 0x30;                //Sending 3
  88               		.loc 1 44 5 view .LVU25
  89               		.loc 1 44 14 is_stmt 0 view .LVU26
  90 002a 80E3      		ldi r24,lo8(48)
  91 002c 88B9      		out 0x8,r24
  45:lcd.h         ****     sbit(PORTA,EN);                //Set Enable Pin
  92               		.loc 1 45 5 is_stmt 1 view .LVU27
  93 002e 179A      		sbi 0x2,7
  46:lcd.h         ****     _delay_ms(5);                    //Delay
  94               		.loc 1 46 5 view .LVU28
  95               	.LVL2:
  96               	.LBB38:
  97               	.LBI38:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
  98               		.loc 2 166 1 view .LVU29
  99               	.LBB39:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 100               		.loc 2 168 2 view .LVU30
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 101               		.loc 2 172 2 view .LVU31
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 102               		.loc 2 173 2 view .LVU32
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 103               		.loc 2 174 2 view .LVU33
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 104               		.loc 2 184 3 view .LVU34
 105               		.loc 2 187 2 view .LVU35
 106 0030 EFE1      		ldi r30,lo8(19999)
 107 0032 FEE4      		ldi r31,hi8(19999)
 108 0034 3197      	1:	sbiw r30,1
 109 0036 01F4      		brne 1b
 110 0038 00C0      		rjmp .
 111 003a 0000      		nop
 112               	.LVL3:
 113               		.loc 2 187 2 is_stmt 0 view .LVU36
 114               	.LBE39:
 115               	.LBE38:
  47:lcd.h         ****     cbit(PORTA,EN);                //Clear Enable Pin
 116               		.loc 1 47 5 is_stmt 1 view .LVU37
 117 003c 1798      		cbi 0x2,7
  48:lcd.h         ****     
  49:lcd.h         ****     _delay_ms(1);
 118               		.loc 1 49 5 view .LVU38
 119               	.LVL4:
 120               	.LBB40:
 121               	.LBI40:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 122               		.loc 2 166 1 view .LVU39
 123               	.LBB41:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 124               		.loc 2 168 2 view .LVU40
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 125               		.loc 2 172 2 view .LVU41
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 126               		.loc 2 173 2 view .LVU42
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 127               		.loc 2 174 2 view .LVU43
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 128               		.loc 2 184 3 view .LVU44
 129               		.loc 2 187 2 view .LVU45
 130 003e EFE9      		ldi r30,lo8(3999)
 131 0040 FFE0      		ldi r31,hi8(3999)
 132 0042 3197      	1:	sbiw r30,1
 133 0044 01F4      		brne 1b
 134 0046 00C0      		rjmp .
 135 0048 0000      		nop
 136               	.LVL5:
 137               		.loc 2 187 2 is_stmt 0 view .LVU46
 138               	.LBE41:
 139               	.LBE40:
  50:lcd.h         ****     
  51:lcd.h         ****     cbit(PORTA,RS);                //RS=0 --- Command Input
 140               		.loc 1 51 5 is_stmt 1 view .LVU47
 141 004a 1398      		cbi 0x2,3
  52:lcd.h         ****     cbit(PORTA,RW);                //RW=0 --- Writing to LCD
 142               		.loc 1 52 5 view .LVU48
 143 004c 1598      		cbi 0x2,5
  53:lcd.h         ****     lcd_port = 0x30;                //Sending 3
 144               		.loc 1 53 5 view .LVU49
 145               		.loc 1 53 14 is_stmt 0 view .LVU50
 146 004e 88B9      		out 0x8,r24
  54:lcd.h         ****     sbit(PORTA,EN);                //Set Enable Pin
 147               		.loc 1 54 5 is_stmt 1 view .LVU51
 148 0050 179A      		sbi 0x2,7
  55:lcd.h         ****     _delay_ms(5);                    //Delay
 149               		.loc 1 55 5 view .LVU52
 150               	.LVL6:
 151               	.LBB42:
 152               	.LBI42:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 153               		.loc 2 166 1 view .LVU53
 154               	.LBB43:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 155               		.loc 2 168 2 view .LVU54
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 156               		.loc 2 172 2 view .LVU55
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 157               		.loc 2 173 2 view .LVU56
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 158               		.loc 2 174 2 view .LVU57
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 159               		.loc 2 184 3 view .LVU58
 160               		.loc 2 187 2 view .LVU59
 161 0052 EFE1      		ldi r30,lo8(19999)
 162 0054 FEE4      		ldi r31,hi8(19999)
 163 0056 3197      	1:	sbiw r30,1
 164 0058 01F4      		brne 1b
 165 005a 00C0      		rjmp .
 166 005c 0000      		nop
 167               	.LVL7:
 168               		.loc 2 187 2 is_stmt 0 view .LVU60
 169               	.LBE43:
 170               	.LBE42:
  56:lcd.h         ****     cbit(PORTA,EN);                //Clear Enable Pin
 171               		.loc 1 56 5 is_stmt 1 view .LVU61
 172 005e 1798      		cbi 0x2,7
  57:lcd.h         ****     
  58:lcd.h         ****     _delay_ms(1);
 173               		.loc 1 58 5 view .LVU62
 174               	.LVL8:
 175               	.LBB44:
 176               	.LBI44:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 177               		.loc 2 166 1 view .LVU63
 178               	.LBB45:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 179               		.loc 2 168 2 view .LVU64
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 180               		.loc 2 172 2 view .LVU65
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 181               		.loc 2 173 2 view .LVU66
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 182               		.loc 2 174 2 view .LVU67
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 183               		.loc 2 184 3 view .LVU68
 184               		.loc 2 187 2 view .LVU69
 185 0060 EFE9      		ldi r30,lo8(3999)
 186 0062 FFE0      		ldi r31,hi8(3999)
 187 0064 3197      	1:	sbiw r30,1
 188 0066 01F4      		brne 1b
 189 0068 00C0      		rjmp .
 190 006a 0000      		nop
 191               	.LVL9:
 192               		.loc 2 187 2 is_stmt 0 view .LVU70
 193               	.LBE45:
 194               	.LBE44:
  59:lcd.h         ****     
  60:lcd.h         ****     cbit(PORTA,RS);                //RS=0 --- Command Input
 195               		.loc 1 60 5 is_stmt 1 view .LVU71
 196 006c 1398      		cbi 0x2,3
  61:lcd.h         ****     cbit(PORTA,RW);                //RW=0 --- Writing to LCD
 197               		.loc 1 61 5 view .LVU72
 198 006e 1598      		cbi 0x2,5
  62:lcd.h         ****     lcd_port = 0x30;                //Sending 3
 199               		.loc 1 62 5 view .LVU73
 200               		.loc 1 62 14 is_stmt 0 view .LVU74
 201 0070 88B9      		out 0x8,r24
  63:lcd.h         ****     sbit(PORTA,EN);                //Set Enable Pin
 202               		.loc 1 63 5 is_stmt 1 view .LVU75
 203 0072 179A      		sbi 0x2,7
  64:lcd.h         ****     _delay_ms(5);                    //Delay
 204               		.loc 1 64 5 view .LVU76
 205               	.LVL10:
 206               	.LBB46:
 207               	.LBI46:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 208               		.loc 2 166 1 view .LVU77
 209               	.LBB47:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 210               		.loc 2 168 2 view .LVU78
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 211               		.loc 2 172 2 view .LVU79
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 212               		.loc 2 173 2 view .LVU80
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 213               		.loc 2 174 2 view .LVU81
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 214               		.loc 2 184 3 view .LVU82
 215               		.loc 2 187 2 view .LVU83
 216 0074 8FE1      		ldi r24,lo8(19999)
 217 0076 9EE4      		ldi r25,hi8(19999)
 218 0078 0197      	1:	sbiw r24,1
 219 007a 01F4      		brne 1b
 220 007c 00C0      		rjmp .
 221 007e 0000      		nop
 222               	.LVL11:
 223               		.loc 2 187 2 is_stmt 0 view .LVU84
 224               	.LBE47:
 225               	.LBE46:
  65:lcd.h         ****     cbit(PORTA,EN);                //Clear Enable Pin
 226               		.loc 1 65 5 is_stmt 1 view .LVU85
 227 0080 1798      		cbi 0x2,7
  66:lcd.h         ****     
  67:lcd.h         ****     _delay_ms(1);
 228               		.loc 1 67 5 view .LVU86
 229               	.LVL12:
 230               	.LBB48:
 231               	.LBI48:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 232               		.loc 2 166 1 view .LVU87
 233               	.LBB49:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 234               		.loc 2 168 2 view .LVU88
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 235               		.loc 2 172 2 view .LVU89
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 236               		.loc 2 173 2 view .LVU90
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 237               		.loc 2 174 2 view .LVU91
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 238               		.loc 2 184 3 view .LVU92
 239               		.loc 2 187 2 view .LVU93
 240 0082 EFE9      		ldi r30,lo8(3999)
 241 0084 FFE0      		ldi r31,hi8(3999)
 242 0086 3197      	1:	sbiw r30,1
 243 0088 01F4      		brne 1b
 244 008a 00C0      		rjmp .
 245 008c 0000      		nop
 246               	.LVL13:
 247               		.loc 2 187 2 is_stmt 0 view .LVU94
 248               	.LBE49:
 249               	.LBE48:
  68:lcd.h         ****     
  69:lcd.h         ****     cbit(PORTA,RS);                //RS=0 --- Command Input
 250               		.loc 1 69 5 is_stmt 1 view .LVU95
 251 008e 1398      		cbi 0x2,3
  70:lcd.h         ****     cbit(PORTA,RW);                //RW=0 --- Writing to LCD
 252               		.loc 1 70 5 view .LVU96
 253 0090 1598      		cbi 0x2,5
  71:lcd.h         ****     lcd_port = 0x20;                //Sending 2 to initialise LCD 4-bit mode
 254               		.loc 1 71 5 view .LVU97
 255               		.loc 1 71 14 is_stmt 0 view .LVU98
 256 0092 80E2      		ldi r24,lo8(32)
 257 0094 88B9      		out 0x8,r24
  72:lcd.h         ****     sbit(PORTA,EN);                //Set Enable Pin
 258               		.loc 1 72 5 is_stmt 1 view .LVU99
 259 0096 179A      		sbi 0x2,7
  73:lcd.h         ****     _delay_ms(5);                    //Delay
 260               		.loc 1 73 5 view .LVU100
 261               	.LVL14:
 262               	.LBB50:
 263               	.LBI50:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 264               		.loc 2 166 1 view .LVU101
 265               	.LBB51:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 266               		.loc 2 168 2 view .LVU102
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 267               		.loc 2 172 2 view .LVU103
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 268               		.loc 2 173 2 view .LVU104
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 269               		.loc 2 174 2 view .LVU105
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 270               		.loc 2 184 3 view .LVU106
 271               		.loc 2 187 2 view .LVU107
 272 0098 8FE1      		ldi r24,lo8(19999)
 273 009a 9EE4      		ldi r25,hi8(19999)
 274 009c 0197      	1:	sbiw r24,1
 275 009e 01F4      		brne 1b
 276 00a0 00C0      		rjmp .
 277 00a2 0000      		nop
 278               	.LVL15:
 279               		.loc 2 187 2 is_stmt 0 view .LVU108
 280               	.LBE51:
 281               	.LBE50:
  74:lcd.h         ****     cbit(PORTA,EN);                //Clear Enable Pin
 282               		.loc 1 74 5 is_stmt 1 view .LVU109
 283 00a4 1798      		cbi 0x2,7
 284               	/* epilogue start */
  75:lcd.h         ****     
  76:lcd.h         ****     
  77:lcd.h         **** }
 285               		.loc 1 77 1 is_stmt 0 view .LVU110
 286 00a6 0895      		ret
 287               		.cfi_endproc
 288               	.LFE7:
 290               	.global	lcd_wr_command
 292               	lcd_wr_command:
 293               	.LVL16:
 294               	.LFB9:
  78:lcd.h         **** 
  79:lcd.h         **** //Function to Initialize LCD
  80:lcd.h         **** void lcd_init()
  81:lcd.h         **** {
  82:lcd.h         ****     lcd_set_4bit();
  83:lcd.h         ****     _delay_ms(1);
  84:lcd.h         ****     
  85:lcd.h         ****     lcd_wr_command(0x28);            //LCD 4-bit mode and 2 lines.
  86:lcd.h         ****     lcd_wr_command(0x01);
  87:lcd.h         ****     lcd_wr_command(0x06);
  88:lcd.h         ****     lcd_wr_command(0x0E);
  89:lcd.h         ****     lcd_wr_command(0x80);
  90:lcd.h         ****     
  91:lcd.h         **** }
  92:lcd.h         **** 
  93:lcd.h         **** 
  94:lcd.h         **** //Function to Write Command on LCD
  95:lcd.h         **** void lcd_wr_command(unsigned char cmd)
  96:lcd.h         **** {
 295               		.loc 1 96 1 is_stmt 1 view -0
 296               		.cfi_startproc
 297               	/* prologue: function */
 298               	/* frame size = 0 */
 299               	/* stack size = 0 */
 300               	.L__stack_usage = 0
  97:lcd.h         ****     unsigned char temp;
 301               		.loc 1 97 5 view .LVU112
  98:lcd.h         ****     temp = cmd;
 302               		.loc 1 98 5 view .LVU113
  99:lcd.h         ****     temp = temp & 0xF0;
 303               		.loc 1 99 5 view .LVU114
 100:lcd.h         ****     lcd_port &= 0x0F;
 304               		.loc 1 100 5 view .LVU115
 305               		.loc 1 100 14 is_stmt 0 view .LVU116
 306 00a8 98B1      		in r25,0x8
 307 00aa 9F70      		andi r25,lo8(15)
 308 00ac 98B9      		out 0x8,r25
 101:lcd.h         ****     lcd_port |= temp;
 309               		.loc 1 101 5 is_stmt 1 view .LVU117
 310               		.loc 1 101 14 is_stmt 0 view .LVU118
 311 00ae 28B1      		in r18,0x8
  99:lcd.h         ****     temp = temp & 0xF0;
 312               		.loc 1 99 10 view .LVU119
 313 00b0 982F      		mov r25,r24
 314 00b2 907F      		andi r25,lo8(-16)
 315               	.LVL17:
 316               		.loc 1 101 14 view .LVU120
 317 00b4 922B      		or r25,r18
 318               	.LVL18:
 319               		.loc 1 101 14 view .LVU121
 320 00b6 98B9      		out 0x8,r25
 102:lcd.h         ****     cbit(PORTA,RS);
 321               		.loc 1 102 5 is_stmt 1 view .LVU122
 322 00b8 1398      		cbi 0x2,3
 103:lcd.h         ****     cbit(PORTA,RW);
 323               		.loc 1 103 5 view .LVU123
 324 00ba 1598      		cbi 0x2,5
 104:lcd.h         ****     sbit(PORTA,EN);
 325               		.loc 1 104 5 view .LVU124
 326 00bc 179A      		sbi 0x2,7
 105:lcd.h         ****     _delay_ms(5);
 327               		.loc 1 105 5 view .LVU125
 328               	.LVL19:
 329               	.LBB52:
 330               	.LBI52:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 331               		.loc 2 166 1 view .LVU126
 332               	.LBB53:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 333               		.loc 2 168 2 view .LVU127
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 334               		.loc 2 172 2 view .LVU128
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 335               		.loc 2 173 2 view .LVU129
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 336               		.loc 2 174 2 view .LVU130
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 337               		.loc 2 184 3 view .LVU131
 338               		.loc 2 187 2 view .LVU132
 339 00be EFE1      		ldi r30,lo8(19999)
 340 00c0 FEE4      		ldi r31,hi8(19999)
 341 00c2 3197      	1:	sbiw r30,1
 342 00c4 01F4      		brne 1b
 343 00c6 00C0      		rjmp .
 344 00c8 0000      		nop
 345               	.LVL20:
 346               		.loc 2 187 2 is_stmt 0 view .LVU133
 347               	.LBE53:
 348               	.LBE52:
 106:lcd.h         ****     cbit(PORTA,EN);
 349               		.loc 1 106 5 is_stmt 1 view .LVU134
 350 00ca 1798      		cbi 0x2,7
 107:lcd.h         ****     
 108:lcd.h         ****     cmd = cmd & 0x0F;
 351               		.loc 1 108 5 view .LVU135
 352               	.LVL21:
 109:lcd.h         ****     cmd = cmd<<4;
 353               		.loc 1 109 5 view .LVU136
 110:lcd.h         ****     lcd_port &= 0x0F;
 354               		.loc 1 110 5 view .LVU137
 355               		.loc 1 110 14 is_stmt 0 view .LVU138
 356 00cc 98B1      		in r25,0x8
 357 00ce 9F70      		andi r25,lo8(15)
 358 00d0 98B9      		out 0x8,r25
 111:lcd.h         ****     lcd_port |= cmd;
 359               		.loc 1 111 5 is_stmt 1 view .LVU139
 360               		.loc 1 111 14 is_stmt 0 view .LVU140
 361 00d2 98B1      		in r25,0x8
 362 00d4 8295      		swap r24
 363               	.LVL22:
 364               		.loc 1 111 14 view .LVU141
 365 00d6 807F      		andi r24,lo8(-16)
 366 00d8 892B      		or r24,r25
 367 00da 88B9      		out 0x8,r24
 112:lcd.h         ****     cbit(PORTA,RS);
 368               		.loc 1 112 5 is_stmt 1 view .LVU142
 369 00dc 1398      		cbi 0x2,3
 113:lcd.h         ****     cbit(PORTA,RW);
 370               		.loc 1 113 5 view .LVU143
 371 00de 1598      		cbi 0x2,5
 114:lcd.h         ****     sbit(PORTA,EN);
 372               		.loc 1 114 5 view .LVU144
 373 00e0 179A      		sbi 0x2,7
 115:lcd.h         ****     _delay_ms(5);
 374               		.loc 1 115 5 view .LVU145
 375               	.LVL23:
 376               	.LBB54:
 377               	.LBI54:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 378               		.loc 2 166 1 view .LVU146
 379               	.LBB55:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 380               		.loc 2 168 2 view .LVU147
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 381               		.loc 2 172 2 view .LVU148
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 382               		.loc 2 173 2 view .LVU149
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 383               		.loc 2 174 2 view .LVU150
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 384               		.loc 2 184 3 view .LVU151
 385               		.loc 2 187 2 view .LVU152
 386 00e2 8FE1      		ldi r24,lo8(19999)
 387 00e4 9EE4      		ldi r25,hi8(19999)
 388 00e6 0197      	1:	sbiw r24,1
 389 00e8 01F4      		brne 1b
 390 00ea 00C0      		rjmp .
 391 00ec 0000      		nop
 392               	.LVL24:
 393               		.loc 2 187 2 is_stmt 0 view .LVU153
 394               	.LBE55:
 395               	.LBE54:
 116:lcd.h         ****     cbit(PORTA,EN);
 396               		.loc 1 116 5 is_stmt 1 view .LVU154
 397 00ee 1798      		cbi 0x2,7
 398               	/* epilogue start */
 117:lcd.h         **** }
 399               		.loc 1 117 1 is_stmt 0 view .LVU155
 400 00f0 0895      		ret
 401               		.cfi_endproc
 402               	.LFE9:
 404               	.global	lcd_init
 406               	lcd_init:
 407               	.LFB8:
  81:lcd.h         ****     lcd_set_4bit();
 408               		.loc 1 81 1 is_stmt 1 view -0
 409               		.cfi_startproc
 410               	/* prologue: function */
 411               	/* frame size = 0 */
 412               	/* stack size = 0 */
 413               	.L__stack_usage = 0
  82:lcd.h         ****     _delay_ms(1);
 414               		.loc 1 82 5 view .LVU157
 415 00f2 0E94 0000 		call lcd_set_4bit
 416               	.LVL25:
  83:lcd.h         ****     
 417               		.loc 1 83 5 view .LVU158
 418               	.LBB56:
 419               	.LBI56:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 420               		.loc 2 166 1 view .LVU159
 421               	.LBB57:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 422               		.loc 2 168 2 view .LVU160
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 423               		.loc 2 172 2 view .LVU161
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 424               		.loc 2 173 2 view .LVU162
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 425               		.loc 2 174 2 view .LVU163
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 426               		.loc 2 184 3 view .LVU164
 427               		.loc 2 187 2 view .LVU165
 428 00f6 8FE9      		ldi r24,lo8(3999)
 429 00f8 9FE0      		ldi r25,hi8(3999)
 430 00fa 0197      	1:	sbiw r24,1
 431 00fc 01F4      		brne 1b
 432 00fe 00C0      		rjmp .
 433 0100 0000      		nop
 434               	.LVL26:
 435               		.loc 2 187 2 is_stmt 0 view .LVU166
 436               	.LBE57:
 437               	.LBE56:
  85:lcd.h         ****     lcd_wr_command(0x01);
 438               		.loc 1 85 5 is_stmt 1 view .LVU167
 439 0102 88E2      		ldi r24,lo8(40)
 440 0104 0E94 0000 		call lcd_wr_command
 441               	.LVL27:
  86:lcd.h         ****     lcd_wr_command(0x06);
 442               		.loc 1 86 5 view .LVU168
 443 0108 81E0      		ldi r24,lo8(1)
 444 010a 0E94 0000 		call lcd_wr_command
 445               	.LVL28:
  87:lcd.h         ****     lcd_wr_command(0x0E);
 446               		.loc 1 87 5 view .LVU169
 447 010e 86E0      		ldi r24,lo8(6)
 448 0110 0E94 0000 		call lcd_wr_command
 449               	.LVL29:
  88:lcd.h         ****     lcd_wr_command(0x80);
 450               		.loc 1 88 5 view .LVU170
 451 0114 8EE0      		ldi r24,lo8(14)
 452 0116 0E94 0000 		call lcd_wr_command
 453               	.LVL30:
  89:lcd.h         ****     
 454               		.loc 1 89 5 view .LVU171
 455 011a 80E8      		ldi r24,lo8(-128)
 456 011c 0C94 0000 		jmp lcd_wr_command
 457               	.LVL31:
 458               		.cfi_endproc
 459               	.LFE8:
 461               	.global	lcd_wr_char
 463               	lcd_wr_char:
 464               	.LVL32:
 465               	.LFB10:
 118:lcd.h         **** 
 119:lcd.h         **** //Function to Write Data on LCD
 120:lcd.h         **** void lcd_wr_char(char letter)
 121:lcd.h         **** {
 466               		.loc 1 121 1 view -0
 467               		.cfi_startproc
 468               	/* prologue: function */
 469               	/* frame size = 0 */
 470               	/* stack size = 0 */
 471               	.L__stack_usage = 0
 122:lcd.h         ****     char temp;
 472               		.loc 1 122 5 view .LVU173
 123:lcd.h         ****     temp = letter;
 473               		.loc 1 123 5 view .LVU174
 124:lcd.h         ****     temp = (temp & 0xF0);
 474               		.loc 1 124 5 view .LVU175
 125:lcd.h         ****     lcd_port &= 0x0F;
 475               		.loc 1 125 5 view .LVU176
 476               		.loc 1 125 14 is_stmt 0 view .LVU177
 477 0120 98B1      		in r25,0x8
 478 0122 9F70      		andi r25,lo8(15)
 479 0124 98B9      		out 0x8,r25
 126:lcd.h         ****     lcd_port |= temp;
 480               		.loc 1 126 5 is_stmt 1 view .LVU178
 481               		.loc 1 126 14 is_stmt 0 view .LVU179
 482 0126 28B1      		in r18,0x8
 124:lcd.h         ****     temp = (temp & 0xF0);
 483               		.loc 1 124 10 view .LVU180
 484 0128 982F      		mov r25,r24
 485 012a 907F      		andi r25,lo8(-16)
 486               	.LVL33:
 487               		.loc 1 126 14 view .LVU181
 488 012c 922B      		or r25,r18
 489               	.LVL34:
 490               		.loc 1 126 14 view .LVU182
 491 012e 98B9      		out 0x8,r25
 127:lcd.h         ****     sbit(PORTA,RS);
 492               		.loc 1 127 5 is_stmt 1 view .LVU183
 493 0130 139A      		sbi 0x2,3
 128:lcd.h         ****     cbit(PORTA,RW);
 494               		.loc 1 128 5 view .LVU184
 495 0132 1598      		cbi 0x2,5
 129:lcd.h         ****     sbit(PORTA,EN);
 496               		.loc 1 129 5 view .LVU185
 497 0134 179A      		sbi 0x2,7
 130:lcd.h         ****     _delay_ms(5);
 498               		.loc 1 130 5 view .LVU186
 499               	.LVL35:
 500               	.LBB58:
 501               	.LBI58:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 502               		.loc 2 166 1 view .LVU187
 503               	.LBB59:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 504               		.loc 2 168 2 view .LVU188
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 505               		.loc 2 172 2 view .LVU189
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 506               		.loc 2 173 2 view .LVU190
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 507               		.loc 2 174 2 view .LVU191
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 508               		.loc 2 184 3 view .LVU192
 509               		.loc 2 187 2 view .LVU193
 510 0136 EFE1      		ldi r30,lo8(19999)
 511 0138 FEE4      		ldi r31,hi8(19999)
 512 013a 3197      	1:	sbiw r30,1
 513 013c 01F4      		brne 1b
 514 013e 00C0      		rjmp .
 515 0140 0000      		nop
 516               	.LVL36:
 517               		.loc 2 187 2 is_stmt 0 view .LVU194
 518               	.LBE59:
 519               	.LBE58:
 131:lcd.h         ****     cbit(PORTA,EN);
 520               		.loc 1 131 5 is_stmt 1 view .LVU195
 521 0142 1798      		cbi 0x2,7
 132:lcd.h         ****     
 133:lcd.h         ****     letter = letter & 0x0F;
 522               		.loc 1 133 5 view .LVU196
 523               	.LVL37:
 134:lcd.h         ****     letter = letter<<4;
 524               		.loc 1 134 5 view .LVU197
 135:lcd.h         ****     lcd_port &= 0x0F;
 525               		.loc 1 135 5 view .LVU198
 526               		.loc 1 135 14 is_stmt 0 view .LVU199
 527 0144 98B1      		in r25,0x8
 528 0146 9F70      		andi r25,lo8(15)
 529 0148 98B9      		out 0x8,r25
 136:lcd.h         ****     lcd_port |= letter;
 530               		.loc 1 136 5 is_stmt 1 view .LVU200
 531               		.loc 1 136 14 is_stmt 0 view .LVU201
 532 014a 98B1      		in r25,0x8
 533 014c 8295      		swap r24
 534               	.LVL38:
 535               		.loc 1 136 14 view .LVU202
 536 014e 807F      		andi r24,lo8(-16)
 537 0150 892B      		or r24,r25
 538 0152 88B9      		out 0x8,r24
 137:lcd.h         ****     sbit(PORTA,RS);
 539               		.loc 1 137 5 is_stmt 1 view .LVU203
 540 0154 139A      		sbi 0x2,3
 138:lcd.h         ****     cbit(PORTA,RW);
 541               		.loc 1 138 5 view .LVU204
 542 0156 1598      		cbi 0x2,5
 139:lcd.h         ****     sbit(PORTA,EN);
 543               		.loc 1 139 5 view .LVU205
 544 0158 179A      		sbi 0x2,7
 140:lcd.h         ****     _delay_ms(5);
 545               		.loc 1 140 5 view .LVU206
 546               	.LVL39:
 547               	.LBB60:
 548               	.LBI60:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 549               		.loc 2 166 1 view .LVU207
 550               	.LBB61:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 551               		.loc 2 168 2 view .LVU208
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 552               		.loc 2 172 2 view .LVU209
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 553               		.loc 2 173 2 view .LVU210
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 554               		.loc 2 174 2 view .LVU211
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 555               		.loc 2 184 3 view .LVU212
 556               		.loc 2 187 2 view .LVU213
 557 015a 8FE1      		ldi r24,lo8(19999)
 558 015c 9EE4      		ldi r25,hi8(19999)
 559 015e 0197      	1:	sbiw r24,1
 560 0160 01F4      		brne 1b
 561 0162 00C0      		rjmp .
 562 0164 0000      		nop
 563               	.LVL40:
 564               		.loc 2 187 2 is_stmt 0 view .LVU214
 565               	.LBE61:
 566               	.LBE60:
 141:lcd.h         ****     cbit(PORTA,EN);
 567               		.loc 1 141 5 is_stmt 1 view .LVU215
 568 0166 1798      		cbi 0x2,7
 569               	/* epilogue start */
 142:lcd.h         **** }
 570               		.loc 1 142 1 is_stmt 0 view .LVU216
 571 0168 0895      		ret
 572               		.cfi_endproc
 573               	.LFE10:
 575               	.global	lcd_home
 577               	lcd_home:
 578               	.LFB11:
 143:lcd.h         **** 
 144:lcd.h         **** 
 145:lcd.h         **** //Function to bring cursor at home position
 146:lcd.h         **** void lcd_home()
 147:lcd.h         **** {
 579               		.loc 1 147 1 is_stmt 1 view -0
 580               		.cfi_startproc
 581               	/* prologue: function */
 582               	/* frame size = 0 */
 583               	/* stack size = 0 */
 584               	.L__stack_usage = 0
 148:lcd.h         ****     lcd_wr_command(0x80);
 585               		.loc 1 148 5 view .LVU218
 586 016a 80E8      		ldi r24,lo8(-128)
 587 016c 0C94 0000 		jmp lcd_wr_command
 588               	.LVL41:
 589               		.cfi_endproc
 590               	.LFE11:
 592               	.global	lcd_string
 594               	lcd_string:
 595               	.LVL42:
 596               	.LFB12:
 149:lcd.h         **** }
 150:lcd.h         **** 
 151:lcd.h         **** 
 152:lcd.h         **** //Function to Print String on LCD
 153:lcd.h         **** void lcd_string(char *str)
 154:lcd.h         **** {
 597               		.loc 1 154 1 view -0
 598               		.cfi_startproc
 599               		.loc 1 154 1 is_stmt 0 view .LVU220
 600 0170 CF93      		push r28
 601               	.LCFI0:
 602               		.cfi_def_cfa_offset 4
 603               		.cfi_offset 28, -3
 604 0172 DF93      		push r29
 605               	.LCFI1:
 606               		.cfi_def_cfa_offset 5
 607               		.cfi_offset 29, -4
 608               	/* prologue: function */
 609               	/* frame size = 0 */
 610               	/* stack size = 2 */
 611               	.L__stack_usage = 2
 612 0174 EC01      		movw r28,r24
 155:lcd.h         ****     while(*str != '\0')
 613               		.loc 1 155 5 is_stmt 1 view .LVU221
 614               	.LVL43:
 615               	.L8:
 616               		.loc 1 155 11 is_stmt 0 view .LVU222
 617 0176 8991      		ld r24,Y+
 618               	.LVL44:
 619               		.loc 1 155 10 view .LVU223
 620 0178 8111      		cpse r24,__zero_reg__
 621 017a 00C0      		rjmp .L9
 622               	/* epilogue start */
 156:lcd.h         ****     {
 157:lcd.h         ****         lcd_wr_char(*str);
 158:lcd.h         ****         str++;
 159:lcd.h         ****     }
 160:lcd.h         **** }
 623               		.loc 1 160 1 view .LVU224
 624 017c DF91      		pop r29
 625 017e CF91      		pop r28
 626               	.LVL45:
 627               		.loc 1 160 1 view .LVU225
 628 0180 0895      		ret
 629               	.LVL46:
 630               	.L9:
 157:lcd.h         ****         str++;
 631               		.loc 1 157 9 is_stmt 1 view .LVU226
 632 0182 0E94 0000 		call lcd_wr_char
 633               	.LVL47:
 158:lcd.h         ****     }
 634               		.loc 1 158 9 view .LVU227
 158:lcd.h         ****     }
 635               		.loc 1 158 9 is_stmt 0 view .LVU228
 636 0186 00C0      		rjmp .L8
 637               		.cfi_endproc
 638               	.LFE12:
 640               	.global	lcd_cursor
 642               	lcd_cursor:
 643               	.LVL48:
 644               	.LFB13:
 161:lcd.h         **** 
 162:lcd.h         **** //Position the LCD cursor at "row", "column".
 163:lcd.h         **** 
 164:lcd.h         **** void lcd_cursor (char row, char column)
 165:lcd.h         **** {
 645               		.loc 1 165 1 is_stmt 1 view -0
 646               		.cfi_startproc
 647               	/* prologue: function */
 648               	/* frame size = 0 */
 649               	/* stack size = 0 */
 650               	.L__stack_usage = 0
 651               		.loc 1 165 1 is_stmt 0 view .LVU230
 652 0188 982F      		mov r25,r24
 653 018a 862F      		mov r24,r22
 654               	.LVL49:
 166:lcd.h         ****     switch (row) {
 655               		.loc 1 166 5 is_stmt 1 view .LVU231
 656 018c 9230      		cpi r25,lo8(2)
 657 018e 01F0      		breq .L11
 658 0190 00F4      		brsh .L12
 167:lcd.h         ****         case 1: lcd_wr_command (0x80 + column - 1); break;
 659               		.loc 1 167 17 is_stmt 0 view .LVU232
 660 0192 8158      		subi r24,lo8(-(127))
 661 0194 9130      		cpi r25,lo8(1)
 662 0196 01F0      		breq .L17
 663 0198 0895      		ret
 664               	.L12:
 665               		.loc 1 167 17 view .LVU233
 666 019a 9330      		cpi r25,lo8(3)
 667 019c 01F0      		breq .L15
 168:lcd.h         ****         case 2: lcd_wr_command (0xc0 + column - 1); break;
 169:lcd.h         ****         case 3: lcd_wr_command (0x94 + column - 1); break;
 170:lcd.h         ****         case 4: lcd_wr_command (0xd4 + column - 1); break;
 668               		.loc 1 170 17 view .LVU234
 669 019e 8D52      		subi r24,lo8(-(-45))
 670 01a0 9430      		cpi r25,lo8(4)
 671 01a2 01F0      		breq .L17
 672 01a4 0895      		ret
 673               	.L11:
 168:lcd.h         ****         case 2: lcd_wr_command (0xc0 + column - 1); break;
 674               		.loc 1 168 17 is_stmt 1 view .LVU235
 675 01a6 8154      		subi r24,lo8(-(-65))
 676               	.L17:
 677               		.loc 1 170 17 is_stmt 0 view .LVU236
 678 01a8 0C94 0000 		jmp lcd_wr_command
 679               	.LVL50:
 680               	.L15:
 169:lcd.h         ****         case 4: lcd_wr_command (0xd4 + column - 1); break;
 681               		.loc 1 169 17 is_stmt 1 view .LVU237
 682 01ac 8D56      		subi r24,lo8(-(-109))
 683 01ae 00C0      		rjmp .L17
 684               		.cfi_endproc
 685               	.LFE13:
 687               	.global	lcd_print
 689               	lcd_print:
 690               	.LVL51:
 691               	.LFB14:
 171:lcd.h         ****         default: break;
 172:lcd.h         ****     }
 173:lcd.h         **** }
 174:lcd.h         **** 
 175:lcd.h         **** //Function To Print Any input value upto the desired digit on LCD
 176:lcd.h         **** void lcd_print (char row, char coloumn, unsigned int value, int digits)
 177:lcd.h         **** {
 692               		.loc 1 177 1 view -0
 693               		.cfi_startproc
 694               		.loc 1 177 1 is_stmt 0 view .LVU239
 695 01b0 0F93      		push r16
 696               	.LCFI2:
 697               		.cfi_def_cfa_offset 4
 698               		.cfi_offset 16, -3
 699 01b2 1F93      		push r17
 700               	.LCFI3:
 701               		.cfi_def_cfa_offset 5
 702               		.cfi_offset 17, -4
 703 01b4 CF93      		push r28
 704               	.LCFI4:
 705               		.cfi_def_cfa_offset 6
 706               		.cfi_offset 28, -5
 707 01b6 DF93      		push r29
 708               	.LCFI5:
 709               		.cfi_def_cfa_offset 7
 710               		.cfi_offset 29, -6
 711               	/* prologue: function */
 712               	/* frame size = 0 */
 713               	/* stack size = 4 */
 714               	.L__stack_usage = 4
 715 01b8 8A01      		movw r16,r20
 716 01ba E901      		movw r28,r18
 178:lcd.h         ****     unsigned char flag=0;
 717               		.loc 1 178 5 is_stmt 1 view .LVU240
 718               	.LVL52:
 179:lcd.h         ****     if(row==0||coloumn==0)
 719               		.loc 1 179 5 view .LVU241
 720               		.loc 1 179 7 is_stmt 0 view .LVU242
 721 01bc 8823      		tst r24
 722 01be 01F0      		breq .L19
 723               		.loc 1 179 14 discriminator 1 view .LVU243
 724 01c0 6111      		cpse r22,__zero_reg__
 725 01c2 00C0      		rjmp .L20
 726               	.L19:
 180:lcd.h         ****     {
 181:lcd.h         ****         lcd_home();
 727               		.loc 1 181 9 is_stmt 1 view .LVU244
 728 01c4 0E94 0000 		call lcd_home
 729               	.LVL53:
 730               	.L21:
 182:lcd.h         ****     }
 183:lcd.h         ****     else
 184:lcd.h         ****     {
 185:lcd.h         ****         lcd_cursor(row,coloumn);
 186:lcd.h         ****     }
 187:lcd.h         ****     if(digits==5 || flag==1)
 731               		.loc 1 187 5 view .LVU245
 732               		.loc 1 187 7 is_stmt 0 view .LVU246
 733 01c8 C530      		cpi r28,5
 734 01ca D105      		cpc r29,__zero_reg__
 735 01cc 01F0      		breq .+2
 736 01ce 00C0      		rjmp .L22
 188:lcd.h         ****     {
 189:lcd.h         ****         million=value/10000+48;
 737               		.loc 1 189 9 is_stmt 1 view .LVU247
 738               		.loc 1 189 22 is_stmt 0 view .LVU248
 739 01d0 C801      		movw r24,r16
 740 01d2 60E1      		ldi r22,lo8(16)
 741 01d4 77E2      		ldi r23,lo8(39)
 742 01d6 0E94 0000 		call __udivmodhi4
 743               		.loc 1 189 28 view .LVU249
 744 01da CB01      		movw r24,r22
 745 01dc C096      		adiw r24,48
 746               		.loc 1 189 16 view .LVU250
 747 01de 9093 0000 		sts million+1,r25
 748 01e2 8093 0000 		sts million,r24
 190:lcd.h         ****         lcd_wr_char(million);
 749               		.loc 1 190 9 is_stmt 1 view .LVU251
 750 01e6 0E94 0000 		call lcd_wr_char
 751               	.LVL54:
 191:lcd.h         ****         flag=1;
 752               		.loc 1 191 9 view .LVU252
 192:lcd.h         ****     }
 193:lcd.h         ****     if(digits==4 || flag==1)
 753               		.loc 1 193 5 view .LVU253
 754               	.L30:
 194:lcd.h         ****     {
 195:lcd.h         ****         temp = value/1000;
 755               		.loc 1 195 9 view .LVU254
 756               		.loc 1 195 21 is_stmt 0 view .LVU255
 757 01ea C801      		movw r24,r16
 758 01ec 68EE      		ldi r22,lo8(-24)
 759 01ee 73E0      		ldi r23,lo8(3)
 760 01f0 0E94 0000 		call __udivmodhi4
 761 01f4 CB01      		movw r24,r22
 762               		.loc 1 195 14 view .LVU256
 763 01f6 7093 0000 		sts temp+1,r23
 764 01fa 6093 0000 		sts temp,r22
 196:lcd.h         ****         thousand = temp%10 + 48;
 765               		.loc 1 196 9 is_stmt 1 view .LVU257
 766               		.loc 1 196 24 is_stmt 0 view .LVU258
 767 01fe 6AE0      		ldi r22,lo8(10)
 768 0200 70E0      		ldi r23,0
 769 0202 0E94 0000 		call __udivmodhi4
 770               		.loc 1 196 28 view .LVU259
 771 0206 C096      		adiw r24,48
 772               		.loc 1 196 18 view .LVU260
 773 0208 9093 0000 		sts thousand+1,r25
 774 020c 8093 0000 		sts thousand,r24
 197:lcd.h         ****         lcd_wr_char(thousand);
 775               		.loc 1 197 9 is_stmt 1 view .LVU261
 776 0210 0E94 0000 		call lcd_wr_char
 777               	.LVL55:
 198:lcd.h         ****         flag=1;
 778               		.loc 1 198 9 view .LVU262
 199:lcd.h         ****     }
 200:lcd.h         ****     if(digits==3 || flag==1)
 779               		.loc 1 200 5 view .LVU263
 780               	.L28:
 201:lcd.h         ****     {
 202:lcd.h         ****         temp = value/100;
 781               		.loc 1 202 9 view .LVU264
 782               		.loc 1 202 21 is_stmt 0 view .LVU265
 783 0214 C801      		movw r24,r16
 784 0216 64E6      		ldi r22,lo8(100)
 785 0218 70E0      		ldi r23,0
 786 021a 0E94 0000 		call __udivmodhi4
 787 021e CB01      		movw r24,r22
 788               		.loc 1 202 14 view .LVU266
 789 0220 7093 0000 		sts temp+1,r23
 790 0224 6093 0000 		sts temp,r22
 203:lcd.h         ****         hundred = temp%10 + 48;
 791               		.loc 1 203 9 is_stmt 1 view .LVU267
 792               		.loc 1 203 23 is_stmt 0 view .LVU268
 793 0228 6AE0      		ldi r22,lo8(10)
 794 022a 70E0      		ldi r23,0
 795 022c 0E94 0000 		call __udivmodhi4
 796               		.loc 1 203 27 view .LVU269
 797 0230 C096      		adiw r24,48
 798               		.loc 1 203 17 view .LVU270
 799 0232 9093 0000 		sts hundred+1,r25
 800 0236 8093 0000 		sts hundred,r24
 204:lcd.h         ****         lcd_wr_char(hundred);
 801               		.loc 1 204 9 is_stmt 1 view .LVU271
 802 023a 0E94 0000 		call lcd_wr_char
 803               	.LVL56:
 205:lcd.h         ****         flag=1;
 804               		.loc 1 205 9 view .LVU272
 206:lcd.h         ****     }
 207:lcd.h         ****     if(digits==2 || flag==1)
 805               		.loc 1 207 5 view .LVU273
 806               	.L26:
 208:lcd.h         ****     {
 209:lcd.h         ****         temp = value/10;
 807               		.loc 1 209 9 view .LVU274
 808               		.loc 1 209 21 is_stmt 0 view .LVU275
 809 023e 2AE0      		ldi r18,lo8(10)
 810 0240 30E0      		ldi r19,0
 811 0242 C801      		movw r24,r16
 812 0244 B901      		movw r22,r18
 813 0246 0E94 0000 		call __udivmodhi4
 814 024a CB01      		movw r24,r22
 815               		.loc 1 209 14 view .LVU276
 816 024c 7093 0000 		sts temp+1,r23
 817 0250 6093 0000 		sts temp,r22
 210:lcd.h         ****         tens = temp%10 + 48;
 818               		.loc 1 210 9 is_stmt 1 view .LVU277
 819               		.loc 1 210 20 is_stmt 0 view .LVU278
 820 0254 B901      		movw r22,r18
 821 0256 0E94 0000 		call __udivmodhi4
 822               		.loc 1 210 24 view .LVU279
 823 025a C096      		adiw r24,48
 824               		.loc 1 210 14 view .LVU280
 825 025c 9093 0000 		sts tens+1,r25
 826 0260 8093 0000 		sts tens,r24
 211:lcd.h         ****         lcd_wr_char(tens);
 827               		.loc 1 211 9 is_stmt 1 view .LVU281
 828 0264 0E94 0000 		call lcd_wr_char
 829               	.LVL57:
 212:lcd.h         ****         flag=1;
 830               		.loc 1 212 9 view .LVU282
 213:lcd.h         ****     }
 214:lcd.h         ****     if(digits==1 || flag==1)
 831               		.loc 1 214 5 view .LVU283
 832               	.L24:
 215:lcd.h         ****     {
 216:lcd.h         ****         unit = value%10 + 48;
 833               		.loc 1 216 9 view .LVU284
 834               		.loc 1 216 21 is_stmt 0 view .LVU285
 835 0268 C801      		movw r24,r16
 836 026a 6AE0      		ldi r22,lo8(10)
 837 026c 70E0      		ldi r23,0
 838 026e 0E94 0000 		call __udivmodhi4
 839               		.loc 1 216 25 view .LVU286
 840 0272 C096      		adiw r24,48
 841               		.loc 1 216 14 view .LVU287
 842 0274 9093 0000 		sts unit+1,r25
 843 0278 8093 0000 		sts unit,r24
 217:lcd.h         ****         lcd_wr_char(unit);
 844               		.loc 1 217 9 is_stmt 1 view .LVU288
 845 027c 0E94 0000 		call lcd_wr_char
 846               	.LVL58:
 847               	.L25:
 218:lcd.h         ****     }
 219:lcd.h         ****     if(digits>5)
 848               		.loc 1 219 5 view .LVU289
 849               		.loc 1 219 7 is_stmt 0 view .LVU290
 850 0280 2697      		sbiw r28,6
 851 0282 04F0      		brlt .L18
 220:lcd.h         ****     {
 221:lcd.h         ****         lcd_wr_char('E');
 852               		.loc 1 221 9 is_stmt 1 view .LVU291
 853 0284 85E4      		ldi r24,lo8(69)
 854               	/* epilogue start */
 222:lcd.h         ****     }
 223:lcd.h         ****     
 224:lcd.h         **** }
 855               		.loc 1 224 1 is_stmt 0 view .LVU292
 856 0286 DF91      		pop r29
 857 0288 CF91      		pop r28
 858               	.LVL59:
 859               		.loc 1 224 1 view .LVU293
 860 028a 1F91      		pop r17
 861 028c 0F91      		pop r16
 862               	.LVL60:
 221:lcd.h         ****     }
 863               		.loc 1 221 9 view .LVU294
 864 028e 0C94 0000 		jmp lcd_wr_char
 865               	.LVL61:
 866               	.L20:
 185:lcd.h         ****     }
 867               		.loc 1 185 9 is_stmt 1 view .LVU295
 868 0292 0E94 0000 		call lcd_cursor
 869               	.LVL62:
 185:lcd.h         ****     }
 870               		.loc 1 185 9 is_stmt 0 view .LVU296
 871 0296 00C0      		rjmp .L21
 872               	.L22:
 193:lcd.h         ****     {
 873               		.loc 1 193 5 is_stmt 1 view .LVU297
 193:lcd.h         ****     {
 874               		.loc 1 193 7 is_stmt 0 view .LVU298
 875 0298 C430      		cpi r28,4
 876 029a D105      		cpc r29,__zero_reg__
 877 029c 01F4      		brne .+2
 878 029e 00C0      		rjmp .L30
 200:lcd.h         ****     {
 879               		.loc 1 200 5 is_stmt 1 view .LVU299
 200:lcd.h         ****     {
 880               		.loc 1 200 7 is_stmt 0 view .LVU300
 881 02a0 C330      		cpi r28,3
 882 02a2 D105      		cpc r29,__zero_reg__
 883 02a4 01F4      		brne .+2
 884 02a6 00C0      		rjmp .L28
 207:lcd.h         ****     {
 885               		.loc 1 207 5 is_stmt 1 view .LVU301
 207:lcd.h         ****     {
 886               		.loc 1 207 7 is_stmt 0 view .LVU302
 887 02a8 C230      		cpi r28,2
 888 02aa D105      		cpc r29,__zero_reg__
 889 02ac 01F0      		breq .L26
 214:lcd.h         ****     {
 890               		.loc 1 214 5 is_stmt 1 view .LVU303
 214:lcd.h         ****     {
 891               		.loc 1 214 7 is_stmt 0 view .LVU304
 892 02ae C130      		cpi r28,1
 893 02b0 D105      		cpc r29,__zero_reg__
 894 02b2 01F4      		brne .L25
 895 02b4 00C0      		rjmp .L24
 896               	.LVL63:
 897               	.L18:
 898               	/* epilogue start */
 899               		.loc 1 224 1 view .LVU305
 900 02b6 DF91      		pop r29
 901 02b8 CF91      		pop r28
 902               	.LVL64:
 903               		.loc 1 224 1 view .LVU306
 904 02ba 1F91      		pop r17
 905 02bc 0F91      		pop r16
 906               	.LVL65:
 907               		.loc 1 224 1 view .LVU307
 908 02be 0895      		ret
 909               		.cfi_endproc
 910               	.LFE14:
 912               	.global	timer5_init
 914               	timer5_init:
 915               	.LFB15:
 916               		.file 3 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** #define red_min 13000
   3:main.c        **** #define green_min 18000
   4:main.c        **** #define blue_min 15000
   5:main.c        **** #define red_max 18000
   6:main.c        **** #define green_max 23000
   7:main.c        **** #define blue_max 19000
   8:main.c        **** 
   9:main.c        **** #include <avr/io.h>
  10:main.c        **** #include <util/delay.h>
  11:main.c        **** #include "lcd.h"
  12:main.c        **** 
  13:main.c        **** int result1,result2,result3,result_left,result_right,result;
  14:main.c        **** uint8_t prev_colour;
  15:main.c        **** uint8_t colour;
  16:main.c        **** 
  17:main.c        **** 
  18:main.c        **** void timer5_init(void)
  19:main.c        **** {
 917               		.loc 3 19 1 is_stmt 1 view -0
 918               		.cfi_startproc
 919               	/* prologue: function */
 920               	/* frame size = 0 */
 921               	/* stack size = 0 */
 922               	.L__stack_usage = 0
  20:main.c        ****     TCCR5A = 0x00;
 923               		.loc 3 20 5 view .LVU309
 924               		.loc 3 20 12 is_stmt 0 view .LVU310
 925 02c0 1092 2001 		sts 288,__zero_reg__
  21:main.c        ****     TCCR5B |= (1<<CS50);
 926               		.loc 3 21 5 is_stmt 1 view .LVU311
 927               		.loc 3 21 12 is_stmt 0 view .LVU312
 928 02c4 E1E2      		ldi r30,lo8(33)
 929 02c6 F1E0      		ldi r31,lo8(1)
 930 02c8 8081      		ld r24,Z
 931 02ca 8160      		ori r24,lo8(1)
 932 02cc 8083      		st Z,r24
  22:main.c        ****     TCNT5 = 0;
 933               		.loc 3 22 5 is_stmt 1 view .LVU313
 934               		.loc 3 22 11 is_stmt 0 view .LVU314
 935 02ce 1092 2501 		sts 292+1,__zero_reg__
 936 02d2 1092 2401 		sts 292,__zero_reg__
 937               	/* epilogue start */
  23:main.c        **** }
 938               		.loc 3 23 1 view .LVU315
 939 02d6 0895      		ret
 940               		.cfi_endproc
 941               	.LFE15:
 943               	.global	timer5_reset
 945               	timer5_reset:
 946               	.LFB16:
  24:main.c        **** 
  25:main.c        **** void timer5_reset(void)
  26:main.c        **** {
 947               		.loc 3 26 1 is_stmt 1 view -0
 948               		.cfi_startproc
 949               	/* prologue: function */
 950               	/* frame size = 0 */
 951               	/* stack size = 0 */
 952               	.L__stack_usage = 0
  27:main.c        ****     TCCR5A = 0x00;
 953               		.loc 3 27 5 view .LVU317
 954               		.loc 3 27 12 is_stmt 0 view .LVU318
 955 02d8 1092 2001 		sts 288,__zero_reg__
  28:main.c        ****     TCCR5B = 0x00;
 956               		.loc 3 28 5 is_stmt 1 view .LVU319
 957               		.loc 3 28 12 is_stmt 0 view .LVU320
 958 02dc 1092 2101 		sts 289,__zero_reg__
  29:main.c        ****     TCNT5 = 0;
 959               		.loc 3 29 5 is_stmt 1 view .LVU321
 960               		.loc 3 29 11 is_stmt 0 view .LVU322
 961 02e0 1092 2501 		sts 292+1,__zero_reg__
 962 02e4 1092 2401 		sts 292,__zero_reg__
 963               	/* epilogue start */
  30:main.c        **** }
 964               		.loc 3 30 1 view .LVU323
 965 02e8 0895      		ret
 966               		.cfi_endproc
 967               	.LFE16:
 969               	.global	tcs_init
 971               	tcs_init:
 972               	.LFB17:
  31:main.c        **** 
  32:main.c        **** void tcs_init(void)
  33:main.c        **** {
 973               		.loc 3 33 1 is_stmt 1 view -0
 974               		.cfi_startproc
 975               	/* prologue: function */
 976               	/* frame size = 0 */
 977               	/* stack size = 0 */
 978               	.L__stack_usage = 0
  34:main.c        ****     DDRB |= 0xF0;//s0 s1 s3 s2
 979               		.loc 3 34 5 view .LVU325
 980               		.loc 3 34 10 is_stmt 0 view .LVU326
 981 02ea 84B1      		in r24,0x4
 982 02ec 806F      		ori r24,lo8(-16)
 983 02ee 84B9      		out 0x4,r24
  35:main.c        ****     DDRD &= ~(1<<0);//input pin
 984               		.loc 3 35 5 is_stmt 1 view .LVU327
 985               		.loc 3 35 10 is_stmt 0 view .LVU328
 986 02f0 5098      		cbi 0xa,0
  36:main.c        ****     PORTB |= (1<<5);
 987               		.loc 3 36 5 is_stmt 1 view .LVU329
 988               		.loc 3 36 11 is_stmt 0 view .LVU330
 989 02f2 2D9A      		sbi 0x5,5
  37:main.c        ****     PORTB &= ~(1<<4);
 990               		.loc 3 37 5 is_stmt 1 view .LVU331
 991               		.loc 3 37 11 is_stmt 0 view .LVU332
 992 02f4 2C98      		cbi 0x5,4
 993               	/* epilogue start */
  38:main.c        **** }
 994               		.loc 3 38 1 view .LVU333
 995 02f6 0895      		ret
 996               		.cfi_endproc
 997               	.LFE17:
 999               	.global	tcs_sensor_value
 1001               	tcs_sensor_value:
 1002               	.LFB18:
  39:main.c        **** 
  40:main.c        **** uint8_t tcs_sensor_value(void)
  41:main.c        **** {
 1003               		.loc 3 41 1 is_stmt 1 view -0
 1004               		.cfi_startproc
 1005               	/* prologue: function */
 1006               	/* frame size = 0 */
 1007               	/* stack size = 0 */
 1008               	.L__stack_usage = 0
  42:main.c        ****     PORTB &= ~((1<<6));
 1009               		.loc 3 42 5 view .LVU335
 1010               		.loc 3 42 11 is_stmt 0 view .LVU336
 1011 02f8 2E98      		cbi 0x5,6
  43:main.c        ****     PORTB |= (1<<7);//no filter
 1012               		.loc 3 43 5 is_stmt 1 view .LVU337
 1013               		.loc 3 43 11 is_stmt 0 view .LVU338
 1014 02fa 2F9A      		sbi 0x5,7
  44:main.c        ****     if(!(PIND & (1<<0)))
 1015               		.loc 3 44 5 is_stmt 1 view .LVU339
 1016               		.loc 3 44 7 is_stmt 0 view .LVU340
 1017 02fc 4899      		sbic 0x9,0
 1018 02fe 00C0      		rjmp .L62
 1019               	.L55:
  45:main.c        ****     {
  46:main.c        ****         while(!(PIND & (1<<0)));
 1020               		.loc 3 46 32 is_stmt 1 discriminator 1 view .LVU341
 1021               		.loc 3 46 14 is_stmt 0 discriminator 1 view .LVU342
 1022 0300 489B      		sbis 0x9,0
 1023 0302 00C0      		rjmp .L55
 1024               	.L62:
  47:main.c        ****     }
  48:main.c        ****     while((PIND & (1<<0)));//Wait for falling edge
 1025               		.loc 3 48 27 is_stmt 1 discriminator 1 view .LVU343
 1026               		.loc 3 48 10 is_stmt 0 discriminator 1 view .LVU344
 1027 0304 4899      		sbic 0x9,0
 1028 0306 00C0      		rjmp .L62
  49:main.c        ****     timer5_init();
 1029               		.loc 3 49 5 is_stmt 1 view .LVU345
 1030 0308 0E94 0000 		call timer5_init
 1031               	.LVL66:
  50:main.c        ****     while(!(PIND & (1<<0)));//Wait for rising edge
 1032               		.loc 3 50 5 view .LVU346
 1033               	.L56:
 1034               		.loc 3 50 28 discriminator 1 view .LVU347
 1035               		.loc 3 50 10 is_stmt 0 discriminator 1 view .LVU348
 1036 030c 489B      		sbis 0x9,0
 1037 030e 00C0      		rjmp .L56
  51:main.c        ****     result = TCNT5;
 1038               		.loc 3 51 5 is_stmt 1 view .LVU349
 1039               		.loc 3 51 14 is_stmt 0 view .LVU350
 1040 0310 8091 2401 		lds r24,292
 1041 0314 9091 2501 		lds r25,292+1
 1042               		.loc 3 51 12 view .LVU351
 1043 0318 9093 0000 		sts result+1,r25
 1044 031c 8093 0000 		sts result,r24
  52:main.c        ****     timer5_reset();
 1045               		.loc 3 52 5 is_stmt 1 view .LVU352
 1046 0320 0E94 0000 		call timer5_reset
 1047               	.LVL67:
  53:main.c        ****     lcd_print(1,1,result,5);
 1048               		.loc 3 53 5 view .LVU353
 1049 0324 4091 0000 		lds r20,result
 1050 0328 5091 0000 		lds r21,result+1
 1051 032c 25E0      		ldi r18,lo8(5)
 1052 032e 30E0      		ldi r19,0
 1053 0330 61E0      		ldi r22,lo8(1)
 1054 0332 81E0      		ldi r24,lo8(1)
 1055 0334 0E94 0000 		call lcd_print
 1056               	.LVL68:
  54:main.c        ****     _delay_ms(100);
 1057               		.loc 3 54 5 view .LVU354
 1058               	.LBB62:
 1059               	.LBI62:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 1060               		.loc 2 166 1 view .LVU355
 1061               	.LBB63:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1062               		.loc 2 168 2 view .LVU356
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1063               		.loc 2 172 2 view .LVU357
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1064               		.loc 2 173 2 view .LVU358
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 1065               		.loc 2 174 2 view .LVU359
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 1066               		.loc 2 184 3 view .LVU360
 1067               		.loc 2 187 2 view .LVU361
 1068 0338 2FEF      		ldi r18,lo8(319999)
 1069 033a 41EE      		ldi r20,hi8(319999)
 1070 033c 84E0      		ldi r24,hlo8(319999)
 1071 033e 2150      	1:	subi r18,1
 1072 0340 4040      		sbci r20,0
 1073 0342 8040      		sbci r24,0
 1074 0344 01F4      		brne 1b
 1075 0346 00C0      		rjmp .
 1076 0348 0000      		nop
 1077               	.LVL69:
 1078               		.loc 2 187 2 is_stmt 0 view .LVU362
 1079               	.LBE63:
 1080               	.LBE62:
  55:main.c        ****     if(result >= red_min && result <= red_max)
 1081               		.loc 3 55 5 is_stmt 1 view .LVU363
 1082               		.loc 3 55 26 is_stmt 0 view .LVU364
 1083 034a 8091 0000 		lds r24,result
 1084 034e 9091 0000 		lds r25,result+1
 1085 0352 9C01      		movw r18,r24
 1086 0354 285C      		subi r18,-56
 1087 0356 3243      		sbci r19,50
 1088               		.loc 3 55 7 view .LVU365
 1089 0358 2938      		cpi r18,-119
 1090 035a 3341      		sbci r19,19
 1091 035c 00F0      		brlo .L58
  56:main.c        ****     {
  57:main.c        ****         return 1;
  58:main.c        ****     }
  59:main.c        ****     else if(result >= green_min && result <= green_max)
 1092               		.loc 3 59 10 is_stmt 1 view .LVU366
 1093               		.loc 3 59 33 is_stmt 0 view .LVU367
 1094 035e 8055      		subi r24,80
 1095 0360 9644      		sbci r25,70
 1096               		.loc 3 59 12 view .LVU368
 1097 0362 8938      		cpi r24,-119
 1098 0364 9341      		sbci r25,19
 1099 0366 00F0      		brlo .L59
  60:main.c        ****     {
  61:main.c        ****         return 2;
  62:main.c        ****     }
  63:main.c        ****     else if(result >= blue_min && result <= blue_max)
  64:main.c        ****     {
  65:main.c        ****         return 3;
  66:main.c        ****     }
  67:main.c        ****     else
  68:main.c        ****     {
  69:main.c        ****         return 0;
 1100               		.loc 3 69 16 view .LVU369
 1101 0368 80E0      		ldi r24,0
 1102 036a 0895      		ret
 1103               	.L58:
  57:main.c        ****     }
 1104               		.loc 3 57 16 view .LVU370
 1105 036c 81E0      		ldi r24,lo8(1)
 1106 036e 0895      		ret
 1107               	.L59:
  61:main.c        ****     }
 1108               		.loc 3 61 16 view .LVU371
 1109 0370 82E0      		ldi r24,lo8(2)
 1110               	/* epilogue start */
  70:main.c        ****     }
  71:main.c        **** }
 1111               		.loc 3 71 1 view .LVU372
 1112 0372 0895      		ret
 1113               		.cfi_endproc
 1114               	.LFE18:
 1116               		.section	.text.startup,"ax",@progbits
 1117               	.global	main
 1119               	main:
 1120               	.LFB19:
  72:main.c        **** 
  73:main.c        **** int main(void)
  74:main.c        **** {
 1121               		.loc 3 74 1 is_stmt 1 view -0
 1122               		.cfi_startproc
 1123               	/* prologue: function */
 1124               	/* frame size = 0 */
 1125               	/* stack size = 0 */
 1126               	.L__stack_usage = 0
  75:main.c        ****     timer5_init();
 1127               		.loc 3 75 5 view .LVU374
 1128 0000 0E94 0000 		call timer5_init
 1129               	.LVL70:
  76:main.c        ****     tcs_init();
 1130               		.loc 3 76 5 view .LVU375
 1131 0004 0E94 0000 		call tcs_init
 1132               	.LVL71:
  77:main.c        ****     lcd_port_config();
 1133               		.loc 3 77 5 view .LVU376
 1134 0008 0E94 0000 		call lcd_port_config
 1135               	.LVL72:
  78:main.c        ****     lcd_init();
 1136               		.loc 3 78 5 view .LVU377
 1137 000c 0E94 0000 		call lcd_init
 1138               	.LVL73:
  79:main.c        ****     DDRK = 0xFF;
 1139               		.loc 3 79 5 view .LVU378
 1140               		.loc 3 79 10 is_stmt 0 view .LVU379
 1141 0010 8FEF      		ldi r24,lo8(-1)
 1142 0012 8093 0701 		sts 263,r24
  80:main.c        ****     PORTK = 0xFF;
 1143               		.loc 3 80 5 is_stmt 1 view .LVU380
 1144               		.loc 3 80 11 is_stmt 0 view .LVU381
 1145 0016 8093 0801 		sts 264,r24
  81:main.c        ****     while(1)
  82:main.c        ****     {
  83:main.c        ****         timer5_init();
  84:main.c        **** //        uint8_t colour = tcs_sensor_value();
  85:main.c        **** //        if(prev_colour == 0)
  86:main.c        **** //        {
  87:main.c        **** //            if(colour == 1)
  88:main.c        **** //            {
  89:main.c        **** //                PORTK |= 0x38;
  90:main.c        **** //                PORTK &= ~(1<<3);
  91:main.c        **** //            }
  92:main.c        **** //            else if(colour == 2)
  93:main.c        **** //            {
  94:main.c        **** //                PORTK |= 0x38;
  95:main.c        **** //                PORTK &= ~(1<<4);
  96:main.c        **** //            }
  97:main.c        **** //            else if(colour == 3)
  98:main.c        **** //            {
  99:main.c        **** //                PORTK |= 0x38;
 100:main.c        **** //                PORTK &= ~(1<<5);
 101:main.c        **** //            }
 102:main.c        **** //            else
 103:main.c        **** //            {
 104:main.c        **** //                PORTK |= 0x38;
 105:main.c        **** //            }
 106:main.c        **** //        }
 107:main.c        **** //        prev_colour = colour;
 108:main.c        **** //        lcd_print(1,10,colour,3);
 109:main.c        ****         PORTB &= ~((1<<6));
 110:main.c        ****         PORTB &= ~(1<<7);//red
 111:main.c        ****         if(!(PIND & (1<<0)))
 112:main.c        ****         {
 113:main.c        ****             while(!(PIND & (1<<0)));
 114:main.c        ****         }
 115:main.c        ****         while((PIND & (1<<0)));//Wait for falling edge
 116:main.c        ****         timer5_init();
 117:main.c        ****         while(!(PIND & (1<<0)));//Wait for rising edge
 118:main.c        ****         result1 = TCNT5;
 119:main.c        ****         lcd_print(1,1,result1,5);
 120:main.c        ****         _delay_ms(100);
 121:main.c        ****         timer5_reset();
 122:main.c        ****         timer5_init();
 123:main.c        ****         PORTB |= (1<<6)|(1<<7);//green
 124:main.c        ****         if(!(PIND & (1<<0)))
 125:main.c        ****         {
 126:main.c        ****             while(!(PIND & (1<<0)));
 127:main.c        ****         }
 128:main.c        ****         while((PIND & (1<<0)));//Wait for falling edge
 129:main.c        ****         timer5_init();
 130:main.c        ****         while(!(PIND & (1<<0)));//Wait for rising edge
 131:main.c        ****         result2 = TCNT5;
 132:main.c        ****         lcd_print(1,8,result2,5);
 133:main.c        ****         _delay_ms(100);
 134:main.c        ****         timer5_reset();
 135:main.c        ****         timer5_init();
 136:main.c        **** //        PORTB &= ~((1<<6));
 137:main.c        **** //        PORTB |= (1<<7);//no filter
 138:main.c        **** //        if(!(PIND & (1<<0)))
 139:main.c        **** //        {
 140:main.c        **** //            while(!(PIND & (1<<0)));
 141:main.c        **** //        }
 142:main.c        **** //        while((PIND & (1<<0)));//Wait for falling edge
 143:main.c        **** //        timer5_init();
 144:main.c        **** //        while(!(PIND & (1<<0)));//Wait for rising edge
 145:main.c        **** //        result = TCNT5;
 146:main.c        **** //        lcd_print(2,1,result,5);
 147:main.c        **** //        _delay_ms(100);
 148:main.c        **** //        timer5_reset();
 149:main.c        ****         timer5_init();
 150:main.c        ****         PORTB &= ~((1<<7));
 151:main.c        ****         PORTB |= (1<<6);//blue
 152:main.c        ****         if(!(PIND & (1<<0)))
 153:main.c        ****         {
 154:main.c        ****             while(!(PIND & (1<<0)));
 155:main.c        ****         }
 156:main.c        ****         while((PIND & (1<<0)));//Wait for falling edge
 157:main.c        ****         timer5_init();
 158:main.c        ****         while(!(PIND & (1<<0)));//Wait for rising edge
 159:main.c        ****         result3 = TCNT5;
 160:main.c        ****         lcd_print(2,8,result3,5);
 161:main.c        ****         _delay_ms(100);
 162:main.c        ****         timer5_reset();
 163:main.c        ****         if(result1 >= red_min && result1 <= red_max)
 164:main.c        ****         {
 165:main.c        ****             if(result2 >= 21000)
 166:main.c        ****             colour = 1;
 167:main.c        ****         }
 168:main.c        ****         else if(result2 >= green_min && result2 <= green_max)
 169:main.c        ****         {
 170:main.c        ****             colour = 2;
 171:main.c        ****         }
 172:main.c        ****         else if(result3 >= blue_min && result3 <= blue_max)
 173:main.c        ****         {
 174:main.c        ****             colour = 3;
 1146               		.loc 3 174 20 view .LVU382
 1147 001a C3E0      		ldi r28,lo8(3)
 1148               	.L67:
  81:main.c        ****     while(1)
 1149               		.loc 3 81 5 is_stmt 1 view .LVU383
  83:main.c        **** //        uint8_t colour = tcs_sensor_value();
 1150               		.loc 3 83 9 view .LVU384
 1151 001c 0E94 0000 		call timer5_init
 1152               	.LVL74:
 109:main.c        ****         PORTB &= ~(1<<7);//red
 1153               		.loc 3 109 9 view .LVU385
 109:main.c        ****         PORTB &= ~(1<<7);//red
 1154               		.loc 3 109 15 is_stmt 0 view .LVU386
 1155 0020 2E98      		cbi 0x5,6
 110:main.c        ****         if(!(PIND & (1<<0)))
 1156               		.loc 3 110 9 is_stmt 1 view .LVU387
 110:main.c        ****         if(!(PIND & (1<<0)))
 1157               		.loc 3 110 15 is_stmt 0 view .LVU388
 1158 0022 2F98      		cbi 0x5,7
 111:main.c        ****         {
 1159               		.loc 3 111 9 is_stmt 1 view .LVU389
 111:main.c        ****         {
 1160               		.loc 3 111 11 is_stmt 0 view .LVU390
 1161 0024 4899      		sbic 0x9,0
 1162 0026 00C0      		rjmp .L93
 1163               	.L69:
 113:main.c        ****         }
 1164               		.loc 3 113 36 is_stmt 1 discriminator 1 view .LVU391
 113:main.c        ****         }
 1165               		.loc 3 113 18 is_stmt 0 discriminator 1 view .LVU392
 1166 0028 489B      		sbis 0x9,0
 1167 002a 00C0      		rjmp .L69
 1168               	.L93:
 115:main.c        ****         timer5_init();
 1169               		.loc 3 115 31 is_stmt 1 discriminator 1 view .LVU393
 115:main.c        ****         timer5_init();
 1170               		.loc 3 115 14 is_stmt 0 discriminator 1 view .LVU394
 1171 002c 4899      		sbic 0x9,0
 1172 002e 00C0      		rjmp .L93
 116:main.c        ****         while(!(PIND & (1<<0)));//Wait for rising edge
 1173               		.loc 3 116 9 is_stmt 1 view .LVU395
 1174 0030 0E94 0000 		call timer5_init
 1175               	.LVL75:
 117:main.c        ****         result1 = TCNT5;
 1176               		.loc 3 117 9 view .LVU396
 1177               	.L70:
 117:main.c        ****         result1 = TCNT5;
 1178               		.loc 3 117 32 discriminator 1 view .LVU397
 117:main.c        ****         result1 = TCNT5;
 1179               		.loc 3 117 14 is_stmt 0 discriminator 1 view .LVU398
 1180 0034 489B      		sbis 0x9,0
 1181 0036 00C0      		rjmp .L70
 118:main.c        ****         lcd_print(1,1,result1,5);
 1182               		.loc 3 118 9 is_stmt 1 view .LVU399
 118:main.c        ****         lcd_print(1,1,result1,5);
 1183               		.loc 3 118 19 is_stmt 0 view .LVU400
 1184 0038 4091 2401 		lds r20,292
 1185 003c 5091 2501 		lds r21,292+1
 118:main.c        ****         lcd_print(1,1,result1,5);
 1186               		.loc 3 118 17 view .LVU401
 1187 0040 5093 0000 		sts result1+1,r21
 1188 0044 4093 0000 		sts result1,r20
 119:main.c        ****         _delay_ms(100);
 1189               		.loc 3 119 9 is_stmt 1 view .LVU402
 1190 0048 25E0      		ldi r18,lo8(5)
 1191 004a 30E0      		ldi r19,0
 1192 004c 61E0      		ldi r22,lo8(1)
 1193 004e 81E0      		ldi r24,lo8(1)
 1194 0050 0E94 0000 		call lcd_print
 1195               	.LVL76:
 120:main.c        ****         timer5_reset();
 1196               		.loc 3 120 9 view .LVU403
 1197               	.LBB64:
 1198               	.LBI64:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 1199               		.loc 2 166 1 view .LVU404
 1200               	.LBB65:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1201               		.loc 2 168 2 view .LVU405
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1202               		.loc 2 172 2 view .LVU406
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1203               		.loc 2 173 2 view .LVU407
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 1204               		.loc 2 174 2 view .LVU408
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 1205               		.loc 2 184 3 view .LVU409
 1206               		.loc 2 187 2 view .LVU410
 1207 0054 2FEF      		ldi r18,lo8(319999)
 1208 0056 41EE      		ldi r20,hi8(319999)
 1209 0058 84E0      		ldi r24,hlo8(319999)
 1210 005a 2150      	1:	subi r18,1
 1211 005c 4040      		sbci r20,0
 1212 005e 8040      		sbci r24,0
 1213 0060 01F4      		brne 1b
 1214 0062 00C0      		rjmp .
 1215 0064 0000      		nop
 1216               	.LVL77:
 1217               		.loc 2 187 2 is_stmt 0 view .LVU411
 1218               	.LBE65:
 1219               	.LBE64:
 121:main.c        ****         timer5_init();
 1220               		.loc 3 121 9 is_stmt 1 view .LVU412
 1221 0066 0E94 0000 		call timer5_reset
 1222               	.LVL78:
 122:main.c        ****         PORTB |= (1<<6)|(1<<7);//green
 1223               		.loc 3 122 9 view .LVU413
 1224 006a 0E94 0000 		call timer5_init
 1225               	.LVL79:
 123:main.c        ****         if(!(PIND & (1<<0)))
 1226               		.loc 3 123 9 view .LVU414
 123:main.c        ****         if(!(PIND & (1<<0)))
 1227               		.loc 3 123 15 is_stmt 0 view .LVU415
 1228 006e 85B1      		in r24,0x5
 1229 0070 806C      		ori r24,lo8(-64)
 1230 0072 85B9      		out 0x5,r24
 124:main.c        ****         {
 1231               		.loc 3 124 9 is_stmt 1 view .LVU416
 124:main.c        ****         {
 1232               		.loc 3 124 11 is_stmt 0 view .LVU417
 1233 0074 4899      		sbic 0x9,0
 1234 0076 00C0      		rjmp .L92
 1235               	.L72:
 126:main.c        ****         }
 1236               		.loc 3 126 36 is_stmt 1 discriminator 1 view .LVU418
 126:main.c        ****         }
 1237               		.loc 3 126 18 is_stmt 0 discriminator 1 view .LVU419
 1238 0078 489B      		sbis 0x9,0
 1239 007a 00C0      		rjmp .L72
 1240               	.L92:
 128:main.c        ****         timer5_init();
 1241               		.loc 3 128 31 is_stmt 1 discriminator 1 view .LVU420
 128:main.c        ****         timer5_init();
 1242               		.loc 3 128 14 is_stmt 0 discriminator 1 view .LVU421
 1243 007c 4899      		sbic 0x9,0
 1244 007e 00C0      		rjmp .L92
 129:main.c        ****         while(!(PIND & (1<<0)));//Wait for rising edge
 1245               		.loc 3 129 9 is_stmt 1 view .LVU422
 1246 0080 0E94 0000 		call timer5_init
 1247               	.LVL80:
 130:main.c        ****         result2 = TCNT5;
 1248               		.loc 3 130 9 view .LVU423
 1249               	.L73:
 130:main.c        ****         result2 = TCNT5;
 1250               		.loc 3 130 32 discriminator 1 view .LVU424
 130:main.c        ****         result2 = TCNT5;
 1251               		.loc 3 130 14 is_stmt 0 discriminator 1 view .LVU425
 1252 0084 489B      		sbis 0x9,0
 1253 0086 00C0      		rjmp .L73
 131:main.c        ****         lcd_print(1,8,result2,5);
 1254               		.loc 3 131 9 is_stmt 1 view .LVU426
 131:main.c        ****         lcd_print(1,8,result2,5);
 1255               		.loc 3 131 19 is_stmt 0 view .LVU427
 1256 0088 4091 2401 		lds r20,292
 1257 008c 5091 2501 		lds r21,292+1
 131:main.c        ****         lcd_print(1,8,result2,5);
 1258               		.loc 3 131 17 view .LVU428
 1259 0090 5093 0000 		sts result2+1,r21
 1260 0094 4093 0000 		sts result2,r20
 132:main.c        ****         _delay_ms(100);
 1261               		.loc 3 132 9 is_stmt 1 view .LVU429
 1262 0098 25E0      		ldi r18,lo8(5)
 1263 009a 30E0      		ldi r19,0
 1264 009c 68E0      		ldi r22,lo8(8)
 1265 009e 81E0      		ldi r24,lo8(1)
 1266 00a0 0E94 0000 		call lcd_print
 1267               	.LVL81:
 133:main.c        ****         timer5_reset();
 1268               		.loc 3 133 9 view .LVU430
 1269               	.LBB66:
 1270               	.LBI66:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 1271               		.loc 2 166 1 view .LVU431
 1272               	.LBB67:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1273               		.loc 2 168 2 view .LVU432
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1274               		.loc 2 172 2 view .LVU433
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1275               		.loc 2 173 2 view .LVU434
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 1276               		.loc 2 174 2 view .LVU435
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 1277               		.loc 2 184 3 view .LVU436
 1278               		.loc 2 187 2 view .LVU437
 1279 00a4 9FEF      		ldi r25,lo8(319999)
 1280 00a6 21EE      		ldi r18,hi8(319999)
 1281 00a8 44E0      		ldi r20,hlo8(319999)
 1282 00aa 9150      	1:	subi r25,1
 1283 00ac 2040      		sbci r18,0
 1284 00ae 4040      		sbci r20,0
 1285 00b0 01F4      		brne 1b
 1286 00b2 00C0      		rjmp .
 1287 00b4 0000      		nop
 1288               	.LVL82:
 1289               		.loc 2 187 2 is_stmt 0 view .LVU438
 1290               	.LBE67:
 1291               	.LBE66:
 134:main.c        ****         timer5_init();
 1292               		.loc 3 134 9 is_stmt 1 view .LVU439
 1293 00b6 0E94 0000 		call timer5_reset
 1294               	.LVL83:
 135:main.c        **** //        PORTB &= ~((1<<6));
 1295               		.loc 3 135 9 view .LVU440
 1296 00ba 0E94 0000 		call timer5_init
 1297               	.LVL84:
 149:main.c        ****         PORTB &= ~((1<<7));
 1298               		.loc 3 149 9 view .LVU441
 1299 00be 0E94 0000 		call timer5_init
 1300               	.LVL85:
 150:main.c        ****         PORTB |= (1<<6);//blue
 1301               		.loc 3 150 9 view .LVU442
 150:main.c        ****         PORTB |= (1<<6);//blue
 1302               		.loc 3 150 15 is_stmt 0 view .LVU443
 1303 00c2 2F98      		cbi 0x5,7
 151:main.c        ****         if(!(PIND & (1<<0)))
 1304               		.loc 3 151 9 is_stmt 1 view .LVU444
 151:main.c        ****         if(!(PIND & (1<<0)))
 1305               		.loc 3 151 15 is_stmt 0 view .LVU445
 1306 00c4 2E9A      		sbi 0x5,6
 152:main.c        ****         {
 1307               		.loc 3 152 9 is_stmt 1 view .LVU446
 152:main.c        ****         {
 1308               		.loc 3 152 11 is_stmt 0 view .LVU447
 1309 00c6 4899      		sbic 0x9,0
 1310 00c8 00C0      		rjmp .L91
 1311               	.L75:
 154:main.c        ****         }
 1312               		.loc 3 154 36 is_stmt 1 discriminator 1 view .LVU448
 154:main.c        ****         }
 1313               		.loc 3 154 18 is_stmt 0 discriminator 1 view .LVU449
 1314 00ca 489B      		sbis 0x9,0
 1315 00cc 00C0      		rjmp .L75
 1316               	.L91:
 156:main.c        ****         timer5_init();
 1317               		.loc 3 156 31 is_stmt 1 discriminator 1 view .LVU450
 156:main.c        ****         timer5_init();
 1318               		.loc 3 156 14 is_stmt 0 discriminator 1 view .LVU451
 1319 00ce 4899      		sbic 0x9,0
 1320 00d0 00C0      		rjmp .L91
 157:main.c        ****         while(!(PIND & (1<<0)));//Wait for rising edge
 1321               		.loc 3 157 9 is_stmt 1 view .LVU452
 1322 00d2 0E94 0000 		call timer5_init
 1323               	.LVL86:
 158:main.c        ****         result3 = TCNT5;
 1324               		.loc 3 158 9 view .LVU453
 1325               	.L76:
 158:main.c        ****         result3 = TCNT5;
 1326               		.loc 3 158 32 discriminator 1 view .LVU454
 158:main.c        ****         result3 = TCNT5;
 1327               		.loc 3 158 14 is_stmt 0 discriminator 1 view .LVU455
 1328 00d6 489B      		sbis 0x9,0
 1329 00d8 00C0      		rjmp .L76
 159:main.c        ****         lcd_print(2,8,result3,5);
 1330               		.loc 3 159 9 is_stmt 1 view .LVU456
 159:main.c        ****         lcd_print(2,8,result3,5);
 1331               		.loc 3 159 19 is_stmt 0 view .LVU457
 1332 00da 4091 2401 		lds r20,292
 1333 00de 5091 2501 		lds r21,292+1
 159:main.c        ****         lcd_print(2,8,result3,5);
 1334               		.loc 3 159 17 view .LVU458
 1335 00e2 5093 0000 		sts result3+1,r21
 1336 00e6 4093 0000 		sts result3,r20
 160:main.c        ****         _delay_ms(100);
 1337               		.loc 3 160 9 is_stmt 1 view .LVU459
 1338 00ea 25E0      		ldi r18,lo8(5)
 1339 00ec 30E0      		ldi r19,0
 1340 00ee 68E0      		ldi r22,lo8(8)
 1341 00f0 82E0      		ldi r24,lo8(2)
 1342 00f2 0E94 0000 		call lcd_print
 1343               	.LVL87:
 161:main.c        ****         timer5_reset();
 1344               		.loc 3 161 9 view .LVU460
 1345               	.LBB68:
 1346               	.LBI68:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 1347               		.loc 2 166 1 view .LVU461
 1348               	.LBB69:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1349               		.loc 2 168 2 view .LVU462
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1350               		.loc 2 172 2 view .LVU463
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1351               		.loc 2 173 2 view .LVU464
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 1352               		.loc 2 174 2 view .LVU465
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 1353               		.loc 2 184 3 view .LVU466
 1354               		.loc 2 187 2 view .LVU467
 1355 00f6 8FEF      		ldi r24,lo8(319999)
 1356 00f8 91EE      		ldi r25,hi8(319999)
 1357 00fa 24E0      		ldi r18,hlo8(319999)
 1358 00fc 8150      	1:	subi r24,1
 1359 00fe 9040      		sbci r25,0
 1360 0100 2040      		sbci r18,0
 1361 0102 01F4      		brne 1b
 1362 0104 00C0      		rjmp .
 1363 0106 0000      		nop
 1364               	.LVL88:
 1365               		.loc 2 187 2 is_stmt 0 view .LVU468
 1366               	.LBE69:
 1367               	.LBE68:
 162:main.c        ****         if(result1 >= red_min && result1 <= red_max)
 1368               		.loc 3 162 9 is_stmt 1 view .LVU469
 1369 0108 0E94 0000 		call timer5_reset
 1370               	.LVL89:
 163:main.c        ****         {
 1371               		.loc 3 163 9 view .LVU470
 163:main.c        ****         {
 1372               		.loc 3 163 31 is_stmt 0 view .LVU471
 1373 010c 2091 0000 		lds r18,result1
 1374 0110 3091 0000 		lds r19,result1+1
 1375 0114 285C      		subi r18,-56
 1376 0116 3243      		sbci r19,50
 1377 0118 8091 0000 		lds r24,result2
 1378 011c 9091 0000 		lds r25,result2+1
 163:main.c        ****         {
 1379               		.loc 3 163 11 view .LVU472
 1380 0120 2938      		cpi r18,-119
 1381 0122 3341      		sbci r19,19
 1382 0124 00F4      		brsh .L77
 165:main.c        ****             colour = 1;
 1383               		.loc 3 165 13 is_stmt 1 view .LVU473
 165:main.c        ****             colour = 1;
 1384               		.loc 3 165 15 is_stmt 0 view .LVU474
 1385 0126 8830      		cpi r24,8
 1386 0128 9245      		sbci r25,82
 1387 012a 04F0      		brlt .L78
 166:main.c        ****         }
 1388               		.loc 3 166 13 is_stmt 1 view .LVU475
 166:main.c        ****         }
 1389               		.loc 3 166 20 is_stmt 0 view .LVU476
 1390 012c 81E0      		ldi r24,lo8(1)
 1391               	.L104:
 170:main.c        ****         }
 1392               		.loc 3 170 20 view .LVU477
 1393 012e 8093 0000 		sts colour,r24
 1394               	.L78:
 175:main.c        ****         }
 176:main.c        ****         else
 177:main.c        ****         {
 178:main.c        ****             colour = 0;
 179:main.c        ****         }
 180:main.c        ****         
 181:main.c        ****         if(colour == 1)
 1395               		.loc 3 181 9 is_stmt 1 view .LVU478
 1396               		.loc 3 181 19 is_stmt 0 view .LVU479
 1397 0132 8091 0000 		lds r24,colour
 1398               		.loc 3 181 11 view .LVU480
 1399 0136 8130      		cpi r24,lo8(1)
 1400 0138 01F4      		brne .L81
 182:main.c        ****         {
 183:main.c        ****             PORTK |= 0x38;
 1401               		.loc 3 183 13 is_stmt 1 view .LVU481
 1402               		.loc 3 183 19 is_stmt 0 view .LVU482
 1403 013a 8091 0801 		lds r24,264
 1404 013e 8863      		ori r24,lo8(56)
 1405 0140 8093 0801 		sts 264,r24
 184:main.c        ****             PORTK &= ~(1<<3);
 1406               		.loc 3 184 13 is_stmt 1 view .LVU483
 1407               		.loc 3 184 19 is_stmt 0 view .LVU484
 1408 0144 8091 0801 		lds r24,264
 1409 0148 877F      		andi r24,lo8(-9)
 1410               	.L103:
 185:main.c        ****         }
 186:main.c        ****         else if(colour == 2)
 187:main.c        ****         {
 188:main.c        ****             PORTK |= 0x38;
 189:main.c        ****             PORTK &= ~(1<<4);
 190:main.c        ****         }
 191:main.c        ****         else if(colour == 3)
 192:main.c        ****         {
 193:main.c        ****             PORTK |= 0x38;
 194:main.c        ****             PORTK &= ~(1<<5);
 195:main.c        ****         }
 196:main.c        ****         else
 197:main.c        ****         {
 198:main.c        ****             PORTK |= 0x38;
 1411               		.loc 3 198 19 view .LVU485
 1412 014a 8093 0801 		sts 264,r24
 1413 014e 00C0      		rjmp .L67
 1414               	.L77:
 168:main.c        ****         {
 1415               		.loc 3 168 14 is_stmt 1 view .LVU486
 168:main.c        ****         {
 1416               		.loc 3 168 38 is_stmt 0 view .LVU487
 1417 0150 8055      		subi r24,80
 1418 0152 9644      		sbci r25,70
 168:main.c        ****         {
 1419               		.loc 3 168 16 view .LVU488
 1420 0154 8938      		cpi r24,-119
 1421 0156 9341      		sbci r25,19
 1422 0158 00F4      		brsh .L79
 170:main.c        ****         }
 1423               		.loc 3 170 13 is_stmt 1 view .LVU489
 170:main.c        ****         }
 1424               		.loc 3 170 20 is_stmt 0 view .LVU490
 1425 015a 82E0      		ldi r24,lo8(2)
 1426 015c 00C0      		rjmp .L104
 1427               	.L79:
 172:main.c        ****         {
 1428               		.loc 3 172 14 is_stmt 1 view .LVU491
 172:main.c        ****         {
 1429               		.loc 3 172 37 is_stmt 0 view .LVU492
 1430 015e 8091 0000 		lds r24,result3
 1431 0162 9091 0000 		lds r25,result3+1
 1432 0166 8859      		subi r24,-104
 1433 0168 9A43      		sbci r25,58
 172:main.c        ****         {
 1434               		.loc 3 172 16 view .LVU493
 1435 016a 813A      		cpi r24,-95
 1436 016c 9F40      		sbci r25,15
 1437 016e 00F4      		brsh .L80
 174:main.c        ****         }
 1438               		.loc 3 174 13 is_stmt 1 view .LVU494
 174:main.c        ****         }
 1439               		.loc 3 174 20 is_stmt 0 view .LVU495
 1440 0170 C093 0000 		sts colour,r28
 1441 0174 00C0      		rjmp .L78
 1442               	.L80:
 178:main.c        ****         }
 1443               		.loc 3 178 13 is_stmt 1 view .LVU496
 178:main.c        ****         }
 1444               		.loc 3 178 20 is_stmt 0 view .LVU497
 1445 0176 1092 0000 		sts colour,__zero_reg__
 1446 017a 00C0      		rjmp .L78
 1447               	.L81:
 186:main.c        ****         {
 1448               		.loc 3 186 14 is_stmt 1 view .LVU498
 186:main.c        ****         {
 1449               		.loc 3 186 16 is_stmt 0 view .LVU499
 1450 017c 8230      		cpi r24,lo8(2)
 1451 017e 01F4      		brne .L83
 188:main.c        ****             PORTK &= ~(1<<4);
 1452               		.loc 3 188 13 is_stmt 1 view .LVU500
 188:main.c        ****             PORTK &= ~(1<<4);
 1453               		.loc 3 188 19 is_stmt 0 view .LVU501
 1454 0180 8091 0801 		lds r24,264
 1455 0184 8863      		ori r24,lo8(56)
 1456 0186 8093 0801 		sts 264,r24
 189:main.c        ****         }
 1457               		.loc 3 189 13 is_stmt 1 view .LVU502
 189:main.c        ****         }
 1458               		.loc 3 189 19 is_stmt 0 view .LVU503
 1459 018a 8091 0801 		lds r24,264
 1460 018e 8F7E      		andi r24,lo8(-17)
 1461 0190 00C0      		rjmp .L103
 1462               	.L83:
 191:main.c        ****         {
 1463               		.loc 3 191 14 is_stmt 1 view .LVU504
 191:main.c        ****         {
 1464               		.loc 3 191 16 is_stmt 0 view .LVU505
 1465 0192 8330      		cpi r24,lo8(3)
 1466 0194 01F4      		brne .L84
 193:main.c        ****             PORTK &= ~(1<<5);
 1467               		.loc 3 193 13 is_stmt 1 view .LVU506
 193:main.c        ****             PORTK &= ~(1<<5);
 1468               		.loc 3 193 19 is_stmt 0 view .LVU507
 1469 0196 8091 0801 		lds r24,264
 1470 019a 8863      		ori r24,lo8(56)
 1471 019c 8093 0801 		sts 264,r24
 194:main.c        ****         }
 1472               		.loc 3 194 13 is_stmt 1 view .LVU508
 194:main.c        ****         }
 1473               		.loc 3 194 19 is_stmt 0 view .LVU509
 1474 01a0 8091 0801 		lds r24,264
 1475 01a4 8F7D      		andi r24,lo8(-33)
 1476 01a6 00C0      		rjmp .L103
 1477               	.L84:
 1478               		.loc 3 198 13 is_stmt 1 view .LVU510
 1479               		.loc 3 198 19 is_stmt 0 view .LVU511
 1480 01a8 8091 0801 		lds r24,264
 1481 01ac 8863      		ori r24,lo8(56)
 1482 01ae 00C0      		rjmp .L103
 1483               		.cfi_endproc
 1484               	.LFE19:
 1486               		.comm	colour,1,1
 1487               		.comm	prev_colour,1,1
 1488               		.comm	result,2,1
 1489               		.comm	result_right,2,1
 1490               		.comm	result_left,2,1
 1491               		.comm	result3,2,1
 1492               		.comm	result2,2,1
 1493               		.comm	result1,2,1
 1494               		.comm	million,2,1
 1495               		.comm	thousand,2,1
 1496               		.comm	hundred,2,1
 1497               		.comm	tens,2,1
 1498               		.comm	unit,2,1
 1499               		.comm	temp,2,1
 1500               		.text
 1501               	.Letext0:
 1502               		.file 4 "/usr/local/Cellar/avr-gcc/8.2.0/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:4      *ABS*:000000000000003f __SREG__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:13     .text:0000000000000000 lcd_port_config
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:53     .text:000000000000001a lcd_set_4bit
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:292    .text:00000000000000a8 lcd_wr_command
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:406    .text:00000000000000f2 lcd_init
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:463    .text:0000000000000120 lcd_wr_char
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:577    .text:000000000000016a lcd_home
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:594    .text:0000000000000170 lcd_string
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:642    .text:0000000000000188 lcd_cursor
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:689    .text:00000000000001b0 lcd_print
                            *COM*:0000000000000002 million
                            *COM*:0000000000000002 temp
                            *COM*:0000000000000002 thousand
                            *COM*:0000000000000002 hundred
                            *COM*:0000000000000002 tens
                            *COM*:0000000000000002 unit
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:914    .text:00000000000002c0 timer5_init
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:945    .text:00000000000002d8 timer5_reset
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:971    .text:00000000000002ea tcs_init
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:1001   .text:00000000000002f8 tcs_sensor_value
                            *COM*:0000000000000002 result
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccY8A2KR.s:1119   .text.startup:0000000000000000 main
                            *COM*:0000000000000002 result1
                            *COM*:0000000000000002 result2
                            *COM*:0000000000000002 result3
                            *COM*:0000000000000001 colour
                            *COM*:0000000000000001 prev_colour
                            *COM*:0000000000000002 result_right
                            *COM*:0000000000000002 result_left

UNDEFINED SYMBOLS
__udivmodhi4
__do_clear_bss
