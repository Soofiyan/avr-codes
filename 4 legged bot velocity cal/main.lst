   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	init_ports
  13               	init_ports:
  14               	.LFB11:
  15               		.file 1 "lcd.h"
   1:lcd.h         **** #define RS 0
   2:lcd.h         **** #define RW 1
   3:lcd.h         **** #define EN 2
   4:lcd.h         **** #define lcd_port PORTC
   5:lcd.h         **** 
   6:lcd.h         **** #define sbit(reg,bit)	reg |= (1<<bit)			// Macro defined for Setting a bit of any register.
   7:lcd.h         **** #define cbit(reg,bit)	reg &= ~(1<<bit)		// Macro defined for Clearing a bit of any register.
   8:lcd.h         **** 
   9:lcd.h         **** void init_ports(void);
  10:lcd.h         **** void lcd_reset();
  11:lcd.h         **** void lcd_init();
  12:lcd.h         **** void lcd_wr_command(unsigned char);
  13:lcd.h         **** void lcd_wr_char(char);
  14:lcd.h         **** void lcd_line1();
  15:lcd.h         **** void lcd_line2();
  16:lcd.h         **** void lcd_string(char*);
  17:lcd.h         **** 
  18:lcd.h         **** unsigned int temp;
  19:lcd.h         **** unsigned int unit;
  20:lcd.h         **** unsigned int tens;
  21:lcd.h         **** unsigned int hundred;
  22:lcd.h         **** unsigned int thousand;
  23:lcd.h         **** unsigned int million;
  24:lcd.h         **** 
  25:lcd.h         **** //Function to configure LCD port
  26:lcd.h         **** void init_ports (void)
  27:lcd.h         **** {
  16               		.loc 1 27 1 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  28:lcd.h         ****  DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
  22               		.loc 1 28 2 view .LVU1
  23               		.loc 1 28 9 is_stmt 0 view .LVU2
  24 0000 87B1      		in r24,0x7
  25               		.loc 1 28 7 view .LVU3
  26 0002 876F      		ori r24,lo8(-9)
  27 0004 87B9      		out 0x7,r24
  29:lcd.h         ****  PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
  28               		.loc 1 29 2 is_stmt 1 view .LVU4
  29               		.loc 1 29 10 is_stmt 0 view .LVU5
  30 0006 88B1      		in r24,0x8
  31               		.loc 1 29 16 view .LVU6
  32 0008 8078      		andi r24,lo8(-128)
  33               		.loc 1 29 8 view .LVU7
  34 000a 88B9      		out 0x8,r24
  35               	/* epilogue start */
  30:lcd.h         **** }
  36               		.loc 1 30 1 view .LVU8
  37 000c 0895      		ret
  38               		.cfi_endproc
  39               	.LFE11:
  41               	.global	lcd_set_4bit
  43               	lcd_set_4bit:
  44               	.LFB12:
  31:lcd.h         **** 
  32:lcd.h         **** 
  33:lcd.h         **** 
  34:lcd.h         **** //Function to Reset LCD
  35:lcd.h         **** void lcd_set_4bit()
  36:lcd.h         **** {
  45               		.loc 1 36 1 is_stmt 1 view -0
  46               		.cfi_startproc
  47               	/* prologue: function */
  48               	/* frame size = 0 */
  49               	/* stack size = 0 */
  50               	.L__stack_usage = 0
  37:lcd.h         **** 	_delay_ms(1);
  51               		.loc 1 37 2 view .LVU10
  52               	.LVL0:
  53               	.LBB33:
  54               	.LBI33:
  55               		.file 2 "/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** _delay_ms(double __ms)
  56               		.loc 2 166 1 view .LVU11
  57               	.LBB34:
 167:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	double __tmp ;
  58               		.loc 2 168 2 view .LVU12
 169:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
  59               		.loc 2 172 2 view .LVU13
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
  60               		.loc 2 173 2 view .LVU14
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
  61               		.loc 2 174 2 view .LVU15
 175:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
  62               		.loc 2 184 3 view .LVU16
 185:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  63               		.loc 2 187 2 view .LVU17
  64 000e 86E6      		ldi r24,lo8(3686)
  65 0010 9EE0      		ldi r25,hi8(3686)
  66 0012 0197      	1:	sbiw r24,1
  67 0014 01F4      		brne 1b
  68 0016 0000      		nop
  69               	.LVL1:
  70               		.loc 2 187 2 is_stmt 0 view .LVU18
  71               	.LBE34:
  72               	.LBE33:
  38:lcd.h         **** 
  39:lcd.h         **** 	cbit(lcd_port,RS);				//RS=0 --- Command Input
  73               		.loc 1 39 2 is_stmt 1 view .LVU19
  74 0018 4098      		cbi 0x8,0
  40:lcd.h         **** 	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
  75               		.loc 1 40 2 view .LVU20
  76 001a 4198      		cbi 0x8,1
  41:lcd.h         **** 	lcd_port = 0x30;				//Sending 3
  77               		.loc 1 41 2 view .LVU21
  78               		.loc 1 41 11 is_stmt 0 view .LVU22
  79 001c 80E3      		ldi r24,lo8(48)
  80 001e 88B9      		out 0x8,r24
  42:lcd.h         **** 	sbit(lcd_port,EN);				//Set Enable Pin
  81               		.loc 1 42 2 is_stmt 1 view .LVU23
  82 0020 429A      		sbi 0x8,2
  43:lcd.h         **** 	_delay_ms(5);					//Delay
  83               		.loc 1 43 2 view .LVU24
  84               	.LVL2:
  85               	.LBB35:
  86               	.LBI35:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
  87               		.loc 2 166 1 view .LVU25
  88               	.LBB36:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  89               		.loc 2 168 2 view .LVU26
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
  90               		.loc 2 172 2 view .LVU27
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
  91               		.loc 2 173 2 view .LVU28
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
  92               		.loc 2 174 2 view .LVU29
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
  93               		.loc 2 184 3 view .LVU30
  94               		.loc 2 187 2 view .LVU31
  95 0022 EFEF      		ldi r30,lo8(18431)
  96 0024 F7E4      		ldi r31,hi8(18431)
  97 0026 3197      	1:	sbiw r30,1
  98 0028 01F4      		brne 1b
  99 002a 00C0      		rjmp .
 100 002c 0000      		nop
 101               	.LVL3:
 102               		.loc 2 187 2 is_stmt 0 view .LVU32
 103               	.LBE36:
 104               	.LBE35:
  44:lcd.h         **** 	cbit(lcd_port,EN);				//Clear Enable Pin
 105               		.loc 1 44 2 is_stmt 1 view .LVU33
 106 002e 4298      		cbi 0x8,2
  45:lcd.h         **** 
  46:lcd.h         **** 	_delay_ms(1);
 107               		.loc 1 46 2 view .LVU34
 108               	.LVL4:
 109               	.LBB37:
 110               	.LBI37:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 111               		.loc 2 166 1 view .LVU35
 112               	.LBB38:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 113               		.loc 2 168 2 view .LVU36
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 114               		.loc 2 172 2 view .LVU37
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 115               		.loc 2 173 2 view .LVU38
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 116               		.loc 2 174 2 view .LVU39
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 117               		.loc 2 184 3 view .LVU40
 118               		.loc 2 187 2 view .LVU41
 119 0030 E6E6      		ldi r30,lo8(3686)
 120 0032 FEE0      		ldi r31,hi8(3686)
 121 0034 3197      	1:	sbiw r30,1
 122 0036 01F4      		brne 1b
 123 0038 0000      		nop
 124               	.LVL5:
 125               		.loc 2 187 2 is_stmt 0 view .LVU42
 126               	.LBE38:
 127               	.LBE37:
  47:lcd.h         **** 
  48:lcd.h         **** 	cbit(lcd_port,RS);				//RS=0 --- Command Input
 128               		.loc 1 48 2 is_stmt 1 view .LVU43
 129 003a 4098      		cbi 0x8,0
  49:lcd.h         **** 	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
 130               		.loc 1 49 2 view .LVU44
 131 003c 4198      		cbi 0x8,1
  50:lcd.h         **** 	lcd_port = 0x30;				//Sending 3
 132               		.loc 1 50 2 view .LVU45
 133               		.loc 1 50 11 is_stmt 0 view .LVU46
 134 003e 88B9      		out 0x8,r24
  51:lcd.h         **** 	sbit(lcd_port,EN);				//Set Enable Pin
 135               		.loc 1 51 2 is_stmt 1 view .LVU47
 136 0040 429A      		sbi 0x8,2
  52:lcd.h         **** 	_delay_ms(5);					//Delay
 137               		.loc 1 52 2 view .LVU48
 138               	.LVL6:
 139               	.LBB39:
 140               	.LBI39:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 141               		.loc 2 166 1 view .LVU49
 142               	.LBB40:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 143               		.loc 2 168 2 view .LVU50
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 144               		.loc 2 172 2 view .LVU51
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 145               		.loc 2 173 2 view .LVU52
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 146               		.loc 2 174 2 view .LVU53
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 147               		.loc 2 184 3 view .LVU54
 148               		.loc 2 187 2 view .LVU55
 149 0042 EFEF      		ldi r30,lo8(18431)
 150 0044 F7E4      		ldi r31,hi8(18431)
 151 0046 3197      	1:	sbiw r30,1
 152 0048 01F4      		brne 1b
 153 004a 00C0      		rjmp .
 154 004c 0000      		nop
 155               	.LVL7:
 156               		.loc 2 187 2 is_stmt 0 view .LVU56
 157               	.LBE40:
 158               	.LBE39:
  53:lcd.h         **** 	cbit(lcd_port,EN);				//Clear Enable Pin
 159               		.loc 1 53 2 is_stmt 1 view .LVU57
 160 004e 4298      		cbi 0x8,2
  54:lcd.h         **** 
  55:lcd.h         **** 	_delay_ms(1);
 161               		.loc 1 55 2 view .LVU58
 162               	.LVL8:
 163               	.LBB41:
 164               	.LBI41:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 165               		.loc 2 166 1 view .LVU59
 166               	.LBB42:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 167               		.loc 2 168 2 view .LVU60
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 168               		.loc 2 172 2 view .LVU61
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 169               		.loc 2 173 2 view .LVU62
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 170               		.loc 2 174 2 view .LVU63
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 171               		.loc 2 184 3 view .LVU64
 172               		.loc 2 187 2 view .LVU65
 173 0050 E6E6      		ldi r30,lo8(3686)
 174 0052 FEE0      		ldi r31,hi8(3686)
 175 0054 3197      	1:	sbiw r30,1
 176 0056 01F4      		brne 1b
 177 0058 0000      		nop
 178               	.LVL9:
 179               		.loc 2 187 2 is_stmt 0 view .LVU66
 180               	.LBE42:
 181               	.LBE41:
  56:lcd.h         **** 
  57:lcd.h         **** 	cbit(lcd_port,RS);				//RS=0 --- Command Input
 182               		.loc 1 57 2 is_stmt 1 view .LVU67
 183 005a 4098      		cbi 0x8,0
  58:lcd.h         **** 	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
 184               		.loc 1 58 2 view .LVU68
 185 005c 4198      		cbi 0x8,1
  59:lcd.h         **** 	lcd_port = 0x30;				//Sending 3
 186               		.loc 1 59 2 view .LVU69
 187               		.loc 1 59 11 is_stmt 0 view .LVU70
 188 005e 88B9      		out 0x8,r24
  60:lcd.h         **** 	sbit(lcd_port,EN);				//Set Enable Pin
 189               		.loc 1 60 2 is_stmt 1 view .LVU71
 190 0060 429A      		sbi 0x8,2
  61:lcd.h         **** 	_delay_ms(5);					//Delay
 191               		.loc 1 61 2 view .LVU72
 192               	.LVL10:
 193               	.LBB43:
 194               	.LBI43:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 195               		.loc 2 166 1 view .LVU73
 196               	.LBB44:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 197               		.loc 2 168 2 view .LVU74
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 198               		.loc 2 172 2 view .LVU75
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 199               		.loc 2 173 2 view .LVU76
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 200               		.loc 2 174 2 view .LVU77
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 201               		.loc 2 184 3 view .LVU78
 202               		.loc 2 187 2 view .LVU79
 203 0062 8FEF      		ldi r24,lo8(18431)
 204 0064 97E4      		ldi r25,hi8(18431)
 205 0066 0197      	1:	sbiw r24,1
 206 0068 01F4      		brne 1b
 207 006a 00C0      		rjmp .
 208 006c 0000      		nop
 209               	.LVL11:
 210               		.loc 2 187 2 is_stmt 0 view .LVU80
 211               	.LBE44:
 212               	.LBE43:
  62:lcd.h         **** 	cbit(lcd_port,EN);				//Clear Enable Pin
 213               		.loc 1 62 2 is_stmt 1 view .LVU81
 214 006e 4298      		cbi 0x8,2
  63:lcd.h         **** 
  64:lcd.h         **** 	_delay_ms(1);
 215               		.loc 1 64 2 view .LVU82
 216               	.LVL12:
 217               	.LBB45:
 218               	.LBI45:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 219               		.loc 2 166 1 view .LVU83
 220               	.LBB46:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 221               		.loc 2 168 2 view .LVU84
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 222               		.loc 2 172 2 view .LVU85
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 223               		.loc 2 173 2 view .LVU86
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 224               		.loc 2 174 2 view .LVU87
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 225               		.loc 2 184 3 view .LVU88
 226               		.loc 2 187 2 view .LVU89
 227 0070 E6E6      		ldi r30,lo8(3686)
 228 0072 FEE0      		ldi r31,hi8(3686)
 229 0074 3197      	1:	sbiw r30,1
 230 0076 01F4      		brne 1b
 231 0078 0000      		nop
 232               	.LVL13:
 233               		.loc 2 187 2 is_stmt 0 view .LVU90
 234               	.LBE46:
 235               	.LBE45:
  65:lcd.h         **** 
  66:lcd.h         **** 	cbit(lcd_port,RS);				//RS=0 --- Command Input
 236               		.loc 1 66 2 is_stmt 1 view .LVU91
 237 007a 4098      		cbi 0x8,0
  67:lcd.h         **** 	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
 238               		.loc 1 67 2 view .LVU92
 239 007c 4198      		cbi 0x8,1
  68:lcd.h         **** 	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
 240               		.loc 1 68 2 view .LVU93
 241               		.loc 1 68 11 is_stmt 0 view .LVU94
 242 007e 80E2      		ldi r24,lo8(32)
 243 0080 88B9      		out 0x8,r24
  69:lcd.h         **** 	sbit(lcd_port,EN);				//Set Enable Pin
 244               		.loc 1 69 2 is_stmt 1 view .LVU95
 245 0082 429A      		sbi 0x8,2
  70:lcd.h         **** 	_delay_ms(5);					//Delay
 246               		.loc 1 70 2 view .LVU96
 247               	.LVL14:
 248               	.LBB47:
 249               	.LBI47:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 250               		.loc 2 166 1 view .LVU97
 251               	.LBB48:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 252               		.loc 2 168 2 view .LVU98
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 253               		.loc 2 172 2 view .LVU99
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 254               		.loc 2 173 2 view .LVU100
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 255               		.loc 2 174 2 view .LVU101
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 256               		.loc 2 184 3 view .LVU102
 257               		.loc 2 187 2 view .LVU103
 258 0084 8FEF      		ldi r24,lo8(18431)
 259 0086 97E4      		ldi r25,hi8(18431)
 260 0088 0197      	1:	sbiw r24,1
 261 008a 01F4      		brne 1b
 262 008c 00C0      		rjmp .
 263 008e 0000      		nop
 264               	.LVL15:
 265               		.loc 2 187 2 is_stmt 0 view .LVU104
 266               	.LBE48:
 267               	.LBE47:
  71:lcd.h         **** 	cbit(lcd_port,EN);				//Clear Enable Pin
 268               		.loc 1 71 2 is_stmt 1 view .LVU105
 269 0090 4298      		cbi 0x8,2
 270               	/* epilogue start */
  72:lcd.h         **** 
  73:lcd.h         **** 	
  74:lcd.h         **** }
 271               		.loc 1 74 1 is_stmt 0 view .LVU106
 272 0092 0895      		ret
 273               		.cfi_endproc
 274               	.LFE12:
 276               	.global	lcd_wr_command
 278               	lcd_wr_command:
 279               	.LVL16:
 280               	.LFB14:
  75:lcd.h         **** 
  76:lcd.h         **** //Function to Initialize LCD
  77:lcd.h         **** void lcd_init()
  78:lcd.h         **** {
  79:lcd.h         **** 	lcd_set_4bit();
  80:lcd.h         **** 	_delay_ms(1);
  81:lcd.h         **** 
  82:lcd.h         **** 	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
  83:lcd.h         **** 	lcd_wr_command(0x01);
  84:lcd.h         **** 	lcd_wr_command(0x06);
  85:lcd.h         **** 	lcd_wr_command(0x0E);
  86:lcd.h         **** 	lcd_wr_command(0x80);
  87:lcd.h         **** 		
  88:lcd.h         **** }
  89:lcd.h         **** 
  90:lcd.h         **** 	 
  91:lcd.h         **** //Function to Write Command on LCD
  92:lcd.h         **** void lcd_wr_command(unsigned char cmd)
  93:lcd.h         **** {
 281               		.loc 1 93 1 is_stmt 1 view -0
 282               		.cfi_startproc
 283               	/* prologue: function */
 284               	/* frame size = 0 */
 285               	/* stack size = 0 */
 286               	.L__stack_usage = 0
  94:lcd.h         **** 	unsigned char temp;
 287               		.loc 1 94 2 view .LVU108
  95:lcd.h         **** 	temp = cmd;
 288               		.loc 1 95 2 view .LVU109
  96:lcd.h         **** 	temp = temp & 0xF0;
 289               		.loc 1 96 2 view .LVU110
  97:lcd.h         **** 	lcd_port &= 0x0F;
 290               		.loc 1 97 2 view .LVU111
 291               		.loc 1 97 11 is_stmt 0 view .LVU112
 292 0094 98B1      		in r25,0x8
 293 0096 9F70      		andi r25,lo8(15)
 294 0098 98B9      		out 0x8,r25
  98:lcd.h         **** 	lcd_port |= temp;
 295               		.loc 1 98 2 is_stmt 1 view .LVU113
 296               		.loc 1 98 11 is_stmt 0 view .LVU114
 297 009a 28B1      		in r18,0x8
  96:lcd.h         **** 	temp = temp & 0xF0;
 298               		.loc 1 96 7 view .LVU115
 299 009c 982F      		mov r25,r24
 300 009e 907F      		andi r25,lo8(-16)
 301               	.LVL17:
 302               		.loc 1 98 11 view .LVU116
 303 00a0 922B      		or r25,r18
 304               	.LVL18:
 305               		.loc 1 98 11 view .LVU117
 306 00a2 98B9      		out 0x8,r25
  99:lcd.h         **** 	cbit(lcd_port,RS);
 307               		.loc 1 99 2 is_stmt 1 view .LVU118
 308 00a4 4098      		cbi 0x8,0
 100:lcd.h         **** 	cbit(lcd_port,RW);
 309               		.loc 1 100 2 view .LVU119
 310 00a6 4198      		cbi 0x8,1
 101:lcd.h         **** 	sbit(lcd_port,EN);
 311               		.loc 1 101 2 view .LVU120
 312 00a8 429A      		sbi 0x8,2
 102:lcd.h         **** 	_delay_ms(5);
 313               		.loc 1 102 2 view .LVU121
 314               	.LVL19:
 315               	.LBB49:
 316               	.LBI49:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 317               		.loc 2 166 1 view .LVU122
 318               	.LBB50:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 319               		.loc 2 168 2 view .LVU123
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 320               		.loc 2 172 2 view .LVU124
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 321               		.loc 2 173 2 view .LVU125
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 322               		.loc 2 174 2 view .LVU126
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 323               		.loc 2 184 3 view .LVU127
 324               		.loc 2 187 2 view .LVU128
 325 00aa EFEF      		ldi r30,lo8(18431)
 326 00ac F7E4      		ldi r31,hi8(18431)
 327 00ae 3197      	1:	sbiw r30,1
 328 00b0 01F4      		brne 1b
 329 00b2 00C0      		rjmp .
 330 00b4 0000      		nop
 331               	.LVL20:
 332               		.loc 2 187 2 is_stmt 0 view .LVU129
 333               	.LBE50:
 334               	.LBE49:
 103:lcd.h         **** 	cbit(lcd_port,EN);
 335               		.loc 1 103 2 is_stmt 1 view .LVU130
 336 00b6 4298      		cbi 0x8,2
 104:lcd.h         **** 	
 105:lcd.h         **** 	cmd = cmd & 0x0F;
 337               		.loc 1 105 2 view .LVU131
 338               	.LVL21:
 106:lcd.h         **** 	cmd = cmd<<4;
 339               		.loc 1 106 2 view .LVU132
 107:lcd.h         **** 	lcd_port &= 0x0F;
 340               		.loc 1 107 2 view .LVU133
 341               		.loc 1 107 11 is_stmt 0 view .LVU134
 342 00b8 98B1      		in r25,0x8
 343 00ba 9F70      		andi r25,lo8(15)
 344 00bc 98B9      		out 0x8,r25
 108:lcd.h         **** 	lcd_port |= cmd;
 345               		.loc 1 108 2 is_stmt 1 view .LVU135
 346               		.loc 1 108 11 is_stmt 0 view .LVU136
 347 00be 98B1      		in r25,0x8
 348 00c0 8295      		swap r24
 349               	.LVL22:
 350               		.loc 1 108 11 view .LVU137
 351 00c2 807F      		andi r24,lo8(-16)
 352 00c4 892B      		or r24,r25
 353 00c6 88B9      		out 0x8,r24
 109:lcd.h         **** 	cbit(lcd_port,RS);
 354               		.loc 1 109 2 is_stmt 1 view .LVU138
 355 00c8 4098      		cbi 0x8,0
 110:lcd.h         **** 	cbit(lcd_port,RW);
 356               		.loc 1 110 2 view .LVU139
 357 00ca 4198      		cbi 0x8,1
 111:lcd.h         **** 	sbit(lcd_port,EN);
 358               		.loc 1 111 2 view .LVU140
 359 00cc 429A      		sbi 0x8,2
 112:lcd.h         **** 	_delay_ms(5);
 360               		.loc 1 112 2 view .LVU141
 361               	.LVL23:
 362               	.LBB51:
 363               	.LBI51:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 364               		.loc 2 166 1 view .LVU142
 365               	.LBB52:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 366               		.loc 2 168 2 view .LVU143
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 367               		.loc 2 172 2 view .LVU144
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 368               		.loc 2 173 2 view .LVU145
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 369               		.loc 2 174 2 view .LVU146
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 370               		.loc 2 184 3 view .LVU147
 371               		.loc 2 187 2 view .LVU148
 372 00ce 8FEF      		ldi r24,lo8(18431)
 373 00d0 97E4      		ldi r25,hi8(18431)
 374 00d2 0197      	1:	sbiw r24,1
 375 00d4 01F4      		brne 1b
 376 00d6 00C0      		rjmp .
 377 00d8 0000      		nop
 378               	.LVL24:
 379               		.loc 2 187 2 is_stmt 0 view .LVU149
 380               	.LBE52:
 381               	.LBE51:
 113:lcd.h         **** 	cbit(lcd_port,EN);
 382               		.loc 1 113 2 is_stmt 1 view .LVU150
 383 00da 4298      		cbi 0x8,2
 384               	/* epilogue start */
 114:lcd.h         **** }
 385               		.loc 1 114 1 is_stmt 0 view .LVU151
 386 00dc 0895      		ret
 387               		.cfi_endproc
 388               	.LFE14:
 390               	.global	lcd_init
 392               	lcd_init:
 393               	.LFB13:
  78:lcd.h         **** 	lcd_set_4bit();
 394               		.loc 1 78 1 is_stmt 1 view -0
 395               		.cfi_startproc
 396               	/* prologue: function */
 397               	/* frame size = 0 */
 398               	/* stack size = 0 */
 399               	.L__stack_usage = 0
  79:lcd.h         **** 	_delay_ms(1);
 400               		.loc 1 79 2 view .LVU153
 401 00de 0E94 0000 		call lcd_set_4bit
 402               	.LVL25:
  80:lcd.h         **** 
 403               		.loc 1 80 2 view .LVU154
 404               	.LBB53:
 405               	.LBI53:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 406               		.loc 2 166 1 view .LVU155
 407               	.LBB54:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 408               		.loc 2 168 2 view .LVU156
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 409               		.loc 2 172 2 view .LVU157
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 410               		.loc 2 173 2 view .LVU158
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 411               		.loc 2 174 2 view .LVU159
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 412               		.loc 2 184 3 view .LVU160
 413               		.loc 2 187 2 view .LVU161
 414 00e2 86E6      		ldi r24,lo8(3686)
 415 00e4 9EE0      		ldi r25,hi8(3686)
 416 00e6 0197      	1:	sbiw r24,1
 417 00e8 01F4      		brne 1b
 418 00ea 0000      		nop
 419               	.LVL26:
 420               		.loc 2 187 2 is_stmt 0 view .LVU162
 421               	.LBE54:
 422               	.LBE53:
  82:lcd.h         **** 	lcd_wr_command(0x01);
 423               		.loc 1 82 2 is_stmt 1 view .LVU163
 424 00ec 88E2      		ldi r24,lo8(40)
 425 00ee 0E94 0000 		call lcd_wr_command
 426               	.LVL27:
  83:lcd.h         **** 	lcd_wr_command(0x06);
 427               		.loc 1 83 2 view .LVU164
 428 00f2 81E0      		ldi r24,lo8(1)
 429 00f4 0E94 0000 		call lcd_wr_command
 430               	.LVL28:
  84:lcd.h         **** 	lcd_wr_command(0x0E);
 431               		.loc 1 84 2 view .LVU165
 432 00f8 86E0      		ldi r24,lo8(6)
 433 00fa 0E94 0000 		call lcd_wr_command
 434               	.LVL29:
  85:lcd.h         **** 	lcd_wr_command(0x80);
 435               		.loc 1 85 2 view .LVU166
 436 00fe 8EE0      		ldi r24,lo8(14)
 437 0100 0E94 0000 		call lcd_wr_command
 438               	.LVL30:
  86:lcd.h         **** 		
 439               		.loc 1 86 2 view .LVU167
 440 0104 80E8      		ldi r24,lo8(-128)
 441 0106 0C94 0000 		jmp lcd_wr_command
 442               	.LVL31:
 443               		.cfi_endproc
 444               	.LFE13:
 446               	.global	lcd_wr_char
 448               	lcd_wr_char:
 449               	.LVL32:
 450               	.LFB15:
 115:lcd.h         **** 
 116:lcd.h         **** //Function to Write Data on LCD
 117:lcd.h         **** void lcd_wr_char(char letter)
 118:lcd.h         **** {
 451               		.loc 1 118 1 view -0
 452               		.cfi_startproc
 453               	/* prologue: function */
 454               	/* frame size = 0 */
 455               	/* stack size = 0 */
 456               	.L__stack_usage = 0
 119:lcd.h         **** 	char temp;
 457               		.loc 1 119 2 view .LVU169
 120:lcd.h         **** 	temp = letter;
 458               		.loc 1 120 2 view .LVU170
 121:lcd.h         **** 	temp = (temp & 0xF0);
 459               		.loc 1 121 2 view .LVU171
 122:lcd.h         **** 	lcd_port &= 0x0F;
 460               		.loc 1 122 2 view .LVU172
 461               		.loc 1 122 11 is_stmt 0 view .LVU173
 462 010a 98B1      		in r25,0x8
 463 010c 9F70      		andi r25,lo8(15)
 464 010e 98B9      		out 0x8,r25
 123:lcd.h         **** 	lcd_port |= temp;
 465               		.loc 1 123 2 is_stmt 1 view .LVU174
 466               		.loc 1 123 11 is_stmt 0 view .LVU175
 467 0110 28B1      		in r18,0x8
 121:lcd.h         **** 	temp = (temp & 0xF0);
 468               		.loc 1 121 7 view .LVU176
 469 0112 982F      		mov r25,r24
 470 0114 907F      		andi r25,lo8(-16)
 471               	.LVL33:
 472               		.loc 1 123 11 view .LVU177
 473 0116 922B      		or r25,r18
 474               	.LVL34:
 475               		.loc 1 123 11 view .LVU178
 476 0118 98B9      		out 0x8,r25
 124:lcd.h         **** 	sbit(lcd_port,RS);
 477               		.loc 1 124 2 is_stmt 1 view .LVU179
 478 011a 409A      		sbi 0x8,0
 125:lcd.h         **** 	cbit(lcd_port,RW);
 479               		.loc 1 125 2 view .LVU180
 480 011c 4198      		cbi 0x8,1
 126:lcd.h         **** 	sbit(lcd_port,EN);
 481               		.loc 1 126 2 view .LVU181
 482 011e 429A      		sbi 0x8,2
 127:lcd.h         **** 	_delay_ms(5);
 483               		.loc 1 127 2 view .LVU182
 484               	.LVL35:
 485               	.LBB55:
 486               	.LBI55:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 487               		.loc 2 166 1 view .LVU183
 488               	.LBB56:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 489               		.loc 2 168 2 view .LVU184
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 490               		.loc 2 172 2 view .LVU185
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 491               		.loc 2 173 2 view .LVU186
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 492               		.loc 2 174 2 view .LVU187
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 493               		.loc 2 184 3 view .LVU188
 494               		.loc 2 187 2 view .LVU189
 495 0120 EFEF      		ldi r30,lo8(18431)
 496 0122 F7E4      		ldi r31,hi8(18431)
 497 0124 3197      	1:	sbiw r30,1
 498 0126 01F4      		brne 1b
 499 0128 00C0      		rjmp .
 500 012a 0000      		nop
 501               	.LVL36:
 502               		.loc 2 187 2 is_stmt 0 view .LVU190
 503               	.LBE56:
 504               	.LBE55:
 128:lcd.h         **** 	cbit(lcd_port,EN);
 505               		.loc 1 128 2 is_stmt 1 view .LVU191
 506 012c 4298      		cbi 0x8,2
 129:lcd.h         **** 
 130:lcd.h         **** 	letter = letter & 0x0F;
 507               		.loc 1 130 2 view .LVU192
 508               	.LVL37:
 131:lcd.h         **** 	letter = letter<<4;
 509               		.loc 1 131 2 view .LVU193
 132:lcd.h         **** 	lcd_port &= 0x0F;
 510               		.loc 1 132 2 view .LVU194
 511               		.loc 1 132 11 is_stmt 0 view .LVU195
 512 012e 98B1      		in r25,0x8
 513 0130 9F70      		andi r25,lo8(15)
 514 0132 98B9      		out 0x8,r25
 133:lcd.h         **** 	lcd_port |= letter;
 515               		.loc 1 133 2 is_stmt 1 view .LVU196
 516               		.loc 1 133 11 is_stmt 0 view .LVU197
 517 0134 98B1      		in r25,0x8
 518 0136 8295      		swap r24
 519               	.LVL38:
 520               		.loc 1 133 11 view .LVU198
 521 0138 807F      		andi r24,lo8(-16)
 522 013a 892B      		or r24,r25
 523 013c 88B9      		out 0x8,r24
 134:lcd.h         **** 	sbit(lcd_port,RS);
 524               		.loc 1 134 2 is_stmt 1 view .LVU199
 525 013e 409A      		sbi 0x8,0
 135:lcd.h         **** 	cbit(lcd_port,RW);
 526               		.loc 1 135 2 view .LVU200
 527 0140 4198      		cbi 0x8,1
 136:lcd.h         **** 	sbit(lcd_port,EN);
 528               		.loc 1 136 2 view .LVU201
 529 0142 429A      		sbi 0x8,2
 137:lcd.h         **** 	_delay_ms(5);
 530               		.loc 1 137 2 view .LVU202
 531               	.LVL39:
 532               	.LBB57:
 533               	.LBI57:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 534               		.loc 2 166 1 view .LVU203
 535               	.LBB58:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 536               		.loc 2 168 2 view .LVU204
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 537               		.loc 2 172 2 view .LVU205
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 538               		.loc 2 173 2 view .LVU206
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 539               		.loc 2 174 2 view .LVU207
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 540               		.loc 2 184 3 view .LVU208
 541               		.loc 2 187 2 view .LVU209
 542 0144 8FEF      		ldi r24,lo8(18431)
 543 0146 97E4      		ldi r25,hi8(18431)
 544 0148 0197      	1:	sbiw r24,1
 545 014a 01F4      		brne 1b
 546 014c 00C0      		rjmp .
 547 014e 0000      		nop
 548               	.LVL40:
 549               		.loc 2 187 2 is_stmt 0 view .LVU210
 550               	.LBE58:
 551               	.LBE57:
 138:lcd.h         **** 	cbit(lcd_port,EN);
 552               		.loc 1 138 2 is_stmt 1 view .LVU211
 553 0150 4298      		cbi 0x8,2
 554               	/* epilogue start */
 139:lcd.h         **** }
 555               		.loc 1 139 1 is_stmt 0 view .LVU212
 556 0152 0895      		ret
 557               		.cfi_endproc
 558               	.LFE15:
 560               	.global	lcd_home
 562               	lcd_home:
 563               	.LFB16:
 140:lcd.h         **** 
 141:lcd.h         **** 
 142:lcd.h         **** //Function to bring cursor at home position
 143:lcd.h         **** void lcd_home()
 144:lcd.h         **** {
 564               		.loc 1 144 1 is_stmt 1 view -0
 565               		.cfi_startproc
 566               	/* prologue: function */
 567               	/* frame size = 0 */
 568               	/* stack size = 0 */
 569               	.L__stack_usage = 0
 145:lcd.h         **** 	lcd_wr_command(0x80);
 570               		.loc 1 145 2 view .LVU214
 571 0154 80E8      		ldi r24,lo8(-128)
 572 0156 0C94 0000 		jmp lcd_wr_command
 573               	.LVL41:
 574               		.cfi_endproc
 575               	.LFE16:
 577               	.global	lcd_string
 579               	lcd_string:
 580               	.LVL42:
 581               	.LFB17:
 146:lcd.h         **** }
 147:lcd.h         **** 
 148:lcd.h         **** 
 149:lcd.h         **** //Function to Print String on LCD
 150:lcd.h         **** void lcd_string(char *str)
 151:lcd.h         **** {
 582               		.loc 1 151 1 view -0
 583               		.cfi_startproc
 584               		.loc 1 151 1 is_stmt 0 view .LVU216
 585 015a CF93      		push r28
 586               	.LCFI0:
 587               		.cfi_def_cfa_offset 4
 588               		.cfi_offset 28, -3
 589 015c DF93      		push r29
 590               	.LCFI1:
 591               		.cfi_def_cfa_offset 5
 592               		.cfi_offset 29, -4
 593               	/* prologue: function */
 594               	/* frame size = 0 */
 595               	/* stack size = 2 */
 596               	.L__stack_usage = 2
 597 015e EC01      		movw r28,r24
 152:lcd.h         **** 	while(*str != '\0')
 598               		.loc 1 152 2 is_stmt 1 view .LVU217
 599               	.LVL43:
 600               	.L8:
 601               		.loc 1 152 8 is_stmt 0 view .LVU218
 602 0160 8991      		ld r24,Y+
 603               	.LVL44:
 604               		.loc 1 152 7 view .LVU219
 605 0162 8111      		cpse r24,__zero_reg__
 606 0164 00C0      		rjmp .L9
 607               	/* epilogue start */
 153:lcd.h         **** 	{
 154:lcd.h         **** 		lcd_wr_char(*str);
 155:lcd.h         **** 		str++;
 156:lcd.h         **** 	}
 157:lcd.h         **** }
 608               		.loc 1 157 1 view .LVU220
 609 0166 DF91      		pop r29
 610 0168 CF91      		pop r28
 611               	.LVL45:
 612               		.loc 1 157 1 view .LVU221
 613 016a 0895      		ret
 614               	.LVL46:
 615               	.L9:
 154:lcd.h         **** 		str++;
 616               		.loc 1 154 3 is_stmt 1 view .LVU222
 617 016c 0E94 0000 		call lcd_wr_char
 618               	.LVL47:
 155:lcd.h         **** 	}
 619               		.loc 1 155 3 view .LVU223
 155:lcd.h         **** 	}
 620               		.loc 1 155 3 is_stmt 0 view .LVU224
 621 0170 00C0      		rjmp .L8
 622               		.cfi_endproc
 623               	.LFE17:
 625               	.global	lcd_cursor
 627               	lcd_cursor:
 628               	.LVL48:
 629               	.LFB18:
 158:lcd.h         **** 
 159:lcd.h         **** //Position the LCD cursor at "row", "column".
 160:lcd.h         **** 
 161:lcd.h         **** void lcd_cursor (char row, char column)
 162:lcd.h         **** {
 630               		.loc 1 162 1 is_stmt 1 view -0
 631               		.cfi_startproc
 632               	/* prologue: function */
 633               	/* frame size = 0 */
 634               	/* stack size = 0 */
 635               	.L__stack_usage = 0
 636               		.loc 1 162 1 is_stmt 0 view .LVU226
 637 0172 982F      		mov r25,r24
 638 0174 862F      		mov r24,r22
 639               	.LVL49:
 163:lcd.h         **** 	switch (row) {
 640               		.loc 1 163 2 is_stmt 1 view .LVU227
 641 0176 9230      		cpi r25,lo8(2)
 642 0178 01F0      		breq .L11
 643 017a 00F4      		brsh .L12
 164:lcd.h         **** 		case 1: lcd_wr_command (0x80 + column - 1); break;
 644               		.loc 1 164 11 is_stmt 0 view .LVU228
 645 017c 8158      		subi r24,lo8(-(127))
 646 017e 9130      		cpi r25,lo8(1)
 647 0180 01F0      		breq .L17
 648 0182 0895      		ret
 649               	.L12:
 650               		.loc 1 164 11 view .LVU229
 651 0184 9330      		cpi r25,lo8(3)
 652 0186 01F0      		breq .L15
 165:lcd.h         **** 		case 2: lcd_wr_command (0xc0 + column - 1); break;
 166:lcd.h         **** 		case 3: lcd_wr_command (0x94 + column - 1); break;
 167:lcd.h         **** 		case 4: lcd_wr_command (0xd4 + column - 1); break;
 653               		.loc 1 167 11 view .LVU230
 654 0188 8D52      		subi r24,lo8(-(-45))
 655 018a 9430      		cpi r25,lo8(4)
 656 018c 01F0      		breq .L17
 657 018e 0895      		ret
 658               	.L11:
 165:lcd.h         **** 		case 2: lcd_wr_command (0xc0 + column - 1); break;
 659               		.loc 1 165 11 is_stmt 1 view .LVU231
 660 0190 8154      		subi r24,lo8(-(-65))
 661               	.L17:
 662               		.loc 1 167 11 is_stmt 0 view .LVU232
 663 0192 0C94 0000 		jmp lcd_wr_command
 664               	.LVL50:
 665               	.L15:
 166:lcd.h         **** 		case 4: lcd_wr_command (0xd4 + column - 1); break;
 666               		.loc 1 166 11 is_stmt 1 view .LVU233
 667 0196 8D56      		subi r24,lo8(-(-109))
 668 0198 00C0      		rjmp .L17
 669               		.cfi_endproc
 670               	.LFE18:
 672               	.global	lcd_print
 674               	lcd_print:
 675               	.LVL51:
 676               	.LFB19:
 168:lcd.h         **** 		default: break;
 169:lcd.h         **** 	}
 170:lcd.h         **** }
 171:lcd.h         **** 
 172:lcd.h         **** //Function To Print Any input value upto the desired digit on LCD
 173:lcd.h         **** void lcd_print (char row, char coloumn, unsigned int value, int digits)
 174:lcd.h         **** {
 677               		.loc 1 174 1 view -0
 678               		.cfi_startproc
 679               		.loc 1 174 1 is_stmt 0 view .LVU235
 680 019a 0F93      		push r16
 681               	.LCFI2:
 682               		.cfi_def_cfa_offset 4
 683               		.cfi_offset 16, -3
 684 019c 1F93      		push r17
 685               	.LCFI3:
 686               		.cfi_def_cfa_offset 5
 687               		.cfi_offset 17, -4
 688 019e CF93      		push r28
 689               	.LCFI4:
 690               		.cfi_def_cfa_offset 6
 691               		.cfi_offset 28, -5
 692 01a0 DF93      		push r29
 693               	.LCFI5:
 694               		.cfi_def_cfa_offset 7
 695               		.cfi_offset 29, -6
 696               	/* prologue: function */
 697               	/* frame size = 0 */
 698               	/* stack size = 4 */
 699               	.L__stack_usage = 4
 700 01a2 8A01      		movw r16,r20
 701 01a4 E901      		movw r28,r18
 175:lcd.h         **** 	unsigned char flag=0;
 702               		.loc 1 175 2 is_stmt 1 view .LVU236
 703               	.LVL52:
 176:lcd.h         **** 	if(row==0||coloumn==0)
 704               		.loc 1 176 2 view .LVU237
 705               		.loc 1 176 4 is_stmt 0 view .LVU238
 706 01a6 8823      		tst r24
 707 01a8 01F0      		breq .L19
 708               		.loc 1 176 11 discriminator 1 view .LVU239
 709 01aa 6111      		cpse r22,__zero_reg__
 710 01ac 00C0      		rjmp .L20
 711               	.L19:
 177:lcd.h         **** 	{
 178:lcd.h         **** 		lcd_home();
 712               		.loc 1 178 3 is_stmt 1 view .LVU240
 713 01ae 0E94 0000 		call lcd_home
 714               	.LVL53:
 715               	.L21:
 179:lcd.h         **** 	}
 180:lcd.h         **** 	else
 181:lcd.h         **** 	{
 182:lcd.h         **** 		lcd_cursor(row,coloumn);
 183:lcd.h         **** 	}
 184:lcd.h         **** 	if(digits==5 || flag==1)
 716               		.loc 1 184 2 view .LVU241
 717               		.loc 1 184 4 is_stmt 0 view .LVU242
 718 01b2 C530      		cpi r28,5
 719 01b4 D105      		cpc r29,__zero_reg__
 720 01b6 01F0      		breq .+2
 721 01b8 00C0      		rjmp .L22
 185:lcd.h         **** 	{
 186:lcd.h         **** 		million=value/10000+48;
 722               		.loc 1 186 3 is_stmt 1 view .LVU243
 723               		.loc 1 186 16 is_stmt 0 view .LVU244
 724 01ba C801      		movw r24,r16
 725 01bc 60E1      		ldi r22,lo8(16)
 726 01be 77E2      		ldi r23,lo8(39)
 727 01c0 0E94 0000 		call __udivmodhi4
 728               		.loc 1 186 22 view .LVU245
 729 01c4 CB01      		movw r24,r22
 730 01c6 C096      		adiw r24,48
 731               		.loc 1 186 10 view .LVU246
 732 01c8 9093 0000 		sts million+1,r25
 733 01cc 8093 0000 		sts million,r24
 187:lcd.h         **** 		lcd_wr_char(million);
 734               		.loc 1 187 3 is_stmt 1 view .LVU247
 735 01d0 0E94 0000 		call lcd_wr_char
 736               	.LVL54:
 188:lcd.h         **** 		flag=1;
 737               		.loc 1 188 3 view .LVU248
 189:lcd.h         **** 	}
 190:lcd.h         **** 	if(digits==4 || flag==1)
 738               		.loc 1 190 2 view .LVU249
 739               	.L30:
 191:lcd.h         **** 	{
 192:lcd.h         **** 		temp = value/1000;
 740               		.loc 1 192 3 view .LVU250
 741               		.loc 1 192 15 is_stmt 0 view .LVU251
 742 01d4 C801      		movw r24,r16
 743 01d6 68EE      		ldi r22,lo8(-24)
 744 01d8 73E0      		ldi r23,lo8(3)
 745 01da 0E94 0000 		call __udivmodhi4
 746 01de CB01      		movw r24,r22
 747               		.loc 1 192 8 view .LVU252
 748 01e0 7093 0000 		sts temp+1,r23
 749 01e4 6093 0000 		sts temp,r22
 193:lcd.h         **** 		thousand = temp%10 + 48;
 750               		.loc 1 193 3 is_stmt 1 view .LVU253
 751               		.loc 1 193 18 is_stmt 0 view .LVU254
 752 01e8 6AE0      		ldi r22,lo8(10)
 753 01ea 70E0      		ldi r23,0
 754 01ec 0E94 0000 		call __udivmodhi4
 755               		.loc 1 193 22 view .LVU255
 756 01f0 C096      		adiw r24,48
 757               		.loc 1 193 12 view .LVU256
 758 01f2 9093 0000 		sts thousand+1,r25
 759 01f6 8093 0000 		sts thousand,r24
 194:lcd.h         **** 		lcd_wr_char(thousand);
 760               		.loc 1 194 3 is_stmt 1 view .LVU257
 761 01fa 0E94 0000 		call lcd_wr_char
 762               	.LVL55:
 195:lcd.h         **** 		flag=1;
 763               		.loc 1 195 3 view .LVU258
 196:lcd.h         **** 	}
 197:lcd.h         **** 	if(digits==3 || flag==1)
 764               		.loc 1 197 2 view .LVU259
 765               	.L28:
 198:lcd.h         **** 	{
 199:lcd.h         **** 		temp = value/100;
 766               		.loc 1 199 3 view .LVU260
 767               		.loc 1 199 15 is_stmt 0 view .LVU261
 768 01fe C801      		movw r24,r16
 769 0200 64E6      		ldi r22,lo8(100)
 770 0202 70E0      		ldi r23,0
 771 0204 0E94 0000 		call __udivmodhi4
 772 0208 CB01      		movw r24,r22
 773               		.loc 1 199 8 view .LVU262
 774 020a 7093 0000 		sts temp+1,r23
 775 020e 6093 0000 		sts temp,r22
 200:lcd.h         **** 		hundred = temp%10 + 48;
 776               		.loc 1 200 3 is_stmt 1 view .LVU263
 777               		.loc 1 200 17 is_stmt 0 view .LVU264
 778 0212 6AE0      		ldi r22,lo8(10)
 779 0214 70E0      		ldi r23,0
 780 0216 0E94 0000 		call __udivmodhi4
 781               		.loc 1 200 21 view .LVU265
 782 021a C096      		adiw r24,48
 783               		.loc 1 200 11 view .LVU266
 784 021c 9093 0000 		sts hundred+1,r25
 785 0220 8093 0000 		sts hundred,r24
 201:lcd.h         **** 		lcd_wr_char(hundred);
 786               		.loc 1 201 3 is_stmt 1 view .LVU267
 787 0224 0E94 0000 		call lcd_wr_char
 788               	.LVL56:
 202:lcd.h         **** 		flag=1;
 789               		.loc 1 202 3 view .LVU268
 203:lcd.h         **** 	}
 204:lcd.h         **** 	if(digits==2 || flag==1)
 790               		.loc 1 204 2 view .LVU269
 791               	.L26:
 205:lcd.h         **** 	{
 206:lcd.h         **** 		temp = value/10;
 792               		.loc 1 206 3 view .LVU270
 793               		.loc 1 206 15 is_stmt 0 view .LVU271
 794 0228 2AE0      		ldi r18,lo8(10)
 795 022a 30E0      		ldi r19,0
 796 022c C801      		movw r24,r16
 797 022e B901      		movw r22,r18
 798 0230 0E94 0000 		call __udivmodhi4
 799 0234 CB01      		movw r24,r22
 800               		.loc 1 206 8 view .LVU272
 801 0236 7093 0000 		sts temp+1,r23
 802 023a 6093 0000 		sts temp,r22
 207:lcd.h         **** 		tens = temp%10 + 48;
 803               		.loc 1 207 3 is_stmt 1 view .LVU273
 804               		.loc 1 207 14 is_stmt 0 view .LVU274
 805 023e B901      		movw r22,r18
 806 0240 0E94 0000 		call __udivmodhi4
 807               		.loc 1 207 18 view .LVU275
 808 0244 C096      		adiw r24,48
 809               		.loc 1 207 8 view .LVU276
 810 0246 9093 0000 		sts tens+1,r25
 811 024a 8093 0000 		sts tens,r24
 208:lcd.h         **** 		lcd_wr_char(tens);
 812               		.loc 1 208 3 is_stmt 1 view .LVU277
 813 024e 0E94 0000 		call lcd_wr_char
 814               	.LVL57:
 209:lcd.h         **** 		flag=1;
 815               		.loc 1 209 3 view .LVU278
 210:lcd.h         **** 	}
 211:lcd.h         **** 	if(digits==1 || flag==1)
 816               		.loc 1 211 2 view .LVU279
 817               	.L24:
 212:lcd.h         **** 	{
 213:lcd.h         **** 		unit = value%10 + 48;
 818               		.loc 1 213 3 view .LVU280
 819               		.loc 1 213 15 is_stmt 0 view .LVU281
 820 0252 C801      		movw r24,r16
 821 0254 6AE0      		ldi r22,lo8(10)
 822 0256 70E0      		ldi r23,0
 823 0258 0E94 0000 		call __udivmodhi4
 824               		.loc 1 213 19 view .LVU282
 825 025c C096      		adiw r24,48
 826               		.loc 1 213 8 view .LVU283
 827 025e 9093 0000 		sts unit+1,r25
 828 0262 8093 0000 		sts unit,r24
 214:lcd.h         **** 		lcd_wr_char(unit);
 829               		.loc 1 214 3 is_stmt 1 view .LVU284
 830 0266 0E94 0000 		call lcd_wr_char
 831               	.LVL58:
 832               	.L25:
 215:lcd.h         **** 	}
 216:lcd.h         **** 	if(digits>5)
 833               		.loc 1 216 2 view .LVU285
 834               		.loc 1 216 4 is_stmt 0 view .LVU286
 835 026a 2697      		sbiw r28,6
 836 026c 04F0      		brlt .L18
 217:lcd.h         **** 	{
 218:lcd.h         **** 		lcd_wr_char('E');
 837               		.loc 1 218 3 is_stmt 1 view .LVU287
 838 026e 85E4      		ldi r24,lo8(69)
 839               	/* epilogue start */
 219:lcd.h         **** 	}
 220:lcd.h         **** 	
 221:lcd.h         **** }
 840               		.loc 1 221 1 is_stmt 0 view .LVU288
 841 0270 DF91      		pop r29
 842 0272 CF91      		pop r28
 843               	.LVL59:
 844               		.loc 1 221 1 view .LVU289
 845 0274 1F91      		pop r17
 846 0276 0F91      		pop r16
 847               	.LVL60:
 218:lcd.h         **** 	}
 848               		.loc 1 218 3 view .LVU290
 849 0278 0C94 0000 		jmp lcd_wr_char
 850               	.LVL61:
 851               	.L20:
 182:lcd.h         **** 	}
 852               		.loc 1 182 3 is_stmt 1 view .LVU291
 853 027c 0E94 0000 		call lcd_cursor
 854               	.LVL62:
 182:lcd.h         **** 	}
 855               		.loc 1 182 3 is_stmt 0 view .LVU292
 856 0280 00C0      		rjmp .L21
 857               	.L22:
 190:lcd.h         **** 	{
 858               		.loc 1 190 2 is_stmt 1 view .LVU293
 190:lcd.h         **** 	{
 859               		.loc 1 190 4 is_stmt 0 view .LVU294
 860 0282 C430      		cpi r28,4
 861 0284 D105      		cpc r29,__zero_reg__
 862 0286 01F4      		brne .+2
 863 0288 00C0      		rjmp .L30
 197:lcd.h         **** 	{
 864               		.loc 1 197 2 is_stmt 1 view .LVU295
 197:lcd.h         **** 	{
 865               		.loc 1 197 4 is_stmt 0 view .LVU296
 866 028a C330      		cpi r28,3
 867 028c D105      		cpc r29,__zero_reg__
 868 028e 01F4      		brne .+2
 869 0290 00C0      		rjmp .L28
 204:lcd.h         **** 	{
 870               		.loc 1 204 2 is_stmt 1 view .LVU297
 204:lcd.h         **** 	{
 871               		.loc 1 204 4 is_stmt 0 view .LVU298
 872 0292 C230      		cpi r28,2
 873 0294 D105      		cpc r29,__zero_reg__
 874 0296 01F0      		breq .L26
 211:lcd.h         **** 	{
 875               		.loc 1 211 2 is_stmt 1 view .LVU299
 211:lcd.h         **** 	{
 876               		.loc 1 211 4 is_stmt 0 view .LVU300
 877 0298 C130      		cpi r28,1
 878 029a D105      		cpc r29,__zero_reg__
 879 029c 01F4      		brne .L25
 880 029e 00C0      		rjmp .L24
 881               	.LVL63:
 882               	.L18:
 883               	/* epilogue start */
 884               		.loc 1 221 1 view .LVU301
 885 02a0 DF91      		pop r29
 886 02a2 CF91      		pop r28
 887               	.LVL64:
 888               		.loc 1 221 1 view .LVU302
 889 02a4 1F91      		pop r17
 890 02a6 0F91      		pop r16
 891               	.LVL65:
 892               		.loc 1 221 1 view .LVU303
 893 02a8 0895      		ret
 894               		.cfi_endproc
 895               	.LFE19:
 897               	.global	bluetooth_init
 899               	bluetooth_init:
 900               	.LFB20:
 901               		.file 3 "main.c"
   1:main.c        **** #define F_CPU 14745600UL
   2:main.c        **** #define BAUD 9600
   3:main.c        **** #define BAUDRATE ((F_CPU/(BAUD*16UL)-1))
   4:main.c        **** 
   5:main.c        **** #include "avr_compiler.h"
   6:main.c        **** #include "lcd.h"
   7:main.c        **** 
   8:main.c        **** bool actuate_out = 0,actuate_in = 0,start = 0;
   9:main.c        **** uint8_t RX_raw,butt[16],RX_ad[4],RX_ad1,RX[4];
  10:main.c        **** float result;
  11:main.c        **** 
  12:main.c        **** void bluetooth_init(void)
  13:main.c        **** {
 902               		.loc 3 13 1 is_stmt 1 view -0
 903               		.cfi_startproc
 904               	/* prologue: function */
 905               	/* frame size = 0 */
 906               	/* stack size = 0 */
 907               	.L__stack_usage = 0
  14:main.c        ****     DDRJ |= (1<<PJ0)|(1<<PJ1);
 908               		.loc 3 14 5 view .LVU305
 909               		.loc 3 14 10 is_stmt 0 view .LVU306
 910 02aa E4E0      		ldi r30,lo8(4)
 911 02ac F1E0      		ldi r31,lo8(1)
 912 02ae 8081      		ld r24,Z
 913 02b0 8360      		ori r24,lo8(3)
 914 02b2 8083      		st Z,r24
  15:main.c        ****     PORTJ |= (1<<PJ1)|(1<<PJ0);//bluetooth
 915               		.loc 3 15 5 is_stmt 1 view .LVU307
 916               		.loc 3 15 11 is_stmt 0 view .LVU308
 917 02b4 E5E0      		ldi r30,lo8(5)
 918 02b6 F1E0      		ldi r31,lo8(1)
 919 02b8 8081      		ld r24,Z
 920 02ba 8360      		ori r24,lo8(3)
 921 02bc 8083      		st Z,r24
 922               	/* epilogue start */
  16:main.c        **** }
 923               		.loc 3 16 1 view .LVU309
 924 02be 0895      		ret
 925               		.cfi_endproc
 926               	.LFE20:
 928               	.global	usart_init
 930               	usart_init:
 931               	.LFB21:
  17:main.c        **** 
  18:main.c        **** void usart_init(void)
  19:main.c        **** {
 932               		.loc 3 19 1 is_stmt 1 view -0
 933               		.cfi_startproc
 934               	/* prologue: function */
 935               	/* frame size = 0 */
 936               	/* stack size = 0 */
 937               	.L__stack_usage = 0
  20:main.c        ****     UBRR3H=BAUDRATE>>8;
 938               		.loc 3 20 5 view .LVU311
 939               		.loc 3 20 11 is_stmt 0 view .LVU312
 940 02c0 1092 3501 		sts 309,__zero_reg__
  21:main.c        ****     UBRR3L=BAUDRATE;
 941               		.loc 3 21 5 is_stmt 1 view .LVU313
 942               		.loc 3 21 11 is_stmt 0 view .LVU314
 943 02c4 8FE5      		ldi r24,lo8(95)
 944 02c6 8093 3401 		sts 308,r24
  22:main.c        ****     UCSR3B=0b10011000;//enable RXEN TXEN
 945               		.loc 3 22 5 is_stmt 1 view .LVU315
 946               		.loc 3 22 11 is_stmt 0 view .LVU316
 947 02ca 88E9      		ldi r24,lo8(-104)
 948 02cc 8093 3101 		sts 305,r24
  23:main.c        ****     UCSR3C=0b00000110;// UCSZ1 UCSZ0
 949               		.loc 3 23 5 is_stmt 1 view .LVU317
 950               		.loc 3 23 11 is_stmt 0 view .LVU318
 951 02d0 86E0      		ldi r24,lo8(6)
 952 02d2 8093 3201 		sts 306,r24
 953               	/* epilogue start */
  24:main.c        **** }
 954               		.loc 3 24 1 view .LVU319
 955 02d6 0895      		ret
 956               		.cfi_endproc
 957               	.LFE21:
 959               	.global	receive
 961               	receive:
 962               	.LFB23:
  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** void ps2_values(void)
  28:main.c        **** {
  29:main.c        ****     if (butt[10]==1)//up
  30:main.c        ****     {
  31:main.c        ****         actuate_out ^=1;
  32:main.c        ****         TCCR3A = 0x00;
  33:main.c        ****         TCCR3B = 0x00;
  34:main.c        ****         TCNT3 = 0;
  35:main.c        ****         butt[10] = 0;
  36:main.c        ****     }
  37:main.c        ****     if (butt[11]==1)//left
  38:main.c        ****     {
  39:main.c        ****         actuate_in ^= 1;
  40:main.c        ****         timer3_init();
  41:main.c        ****         butt[11] = 0;
  42:main.c        ****     }
  43:main.c        ****     if (butt[12]==1)//down
  44:main.c        ****     {
  45:main.c        ****         actuate_out ^= 1;
  46:main.c        ****         TCCR3A = 0x00;
  47:main.c        ****         TCCR3B = 0x00;
  48:main.c        ****         TCNT3 = 0;
  49:main.c        ****         butt[12] = 0;
  50:main.c        ****     }
  51:main.c        ****     if (butt[13]==1)//right
  52:main.c        ****     {
  53:main.c        ****         actuate_in ^= 1;
  54:main.c        ****         timer3_init();
  55:main.c        ****         butt[13] = 0;
  56:main.c        ****     }
  57:main.c        ****     if (butt[14]==1)//start
  58:main.c        ****     {
  59:main.c        ****         start ^= 1;
  60:main.c        ****         butt[14] = 0;
  61:main.c        ****     }
  62:main.c        **** }
  63:main.c        **** 
  64:main.c        **** void receive(void)
  65:main.c        **** {
 963               		.loc 3 65 1 is_stmt 1 view -0
 964               		.cfi_startproc
 965               	/* prologue: function */
 966               	/* frame size = 0 */
 967               	/* stack size = 0 */
 968               	.L__stack_usage = 0
  66:main.c        ****     if ((RX_raw>200) && (RX_raw<255))
 969               		.loc 3 66 5 view .LVU321
 970               		.loc 3 66 22 is_stmt 0 view .LVU322
 971 02d8 E091 0000 		lds r30,RX_raw
 972 02dc 87E3      		ldi r24,lo8(55)
 973 02de 8E0F      		add r24,r30
 974               		.loc 3 66 8 view .LVU323
 975 02e0 8633      		cpi r24,lo8(54)
 976 02e2 00F4      		brsh .L53
  67:main.c        ****     {
  68:main.c        ****         RX_ad1=RX_raw;
 977               		.loc 3 68 9 is_stmt 1 view .LVU324
 978               		.loc 3 68 15 is_stmt 0 view .LVU325
 979 02e4 E093 0000 		sts RX_ad1,r30
  69:main.c        ****         if ((RX_raw>230) && (RX_raw<247))
 980               		.loc 3 69 9 is_stmt 1 view .LVU326
 981               		.loc 3 69 26 is_stmt 0 view .LVU327
 982 02e8 E75E      		subi r30,lo8(-(25))
 983               		.loc 3 69 12 view .LVU328
 984 02ea E031      		cpi r30,lo8(16)
 985 02ec 00F4      		brsh .L52
 986               	.LBB59:
  70:main.c        ****         {
  71:main.c        ****             uint8_t r_temp0=(RX_raw-231);
 987               		.loc 3 71 13 is_stmt 1 view .LVU329
 988               	.LVL66:
  72:main.c        ****             butt[r_temp0]=1;
 989               		.loc 3 72 13 view .LVU330
 990               		.loc 3 72 17 is_stmt 0 view .LVU331
 991 02ee F0E0      		ldi r31,0
 992               		.loc 3 72 26 view .LVU332
 993 02f0 E050      		subi r30,lo8(-(butt))
 994 02f2 F040      		sbci r31,hi8(-(butt))
 995               	.LVL67:
 996               		.loc 3 72 26 view .LVU333
 997 02f4 81E0      		ldi r24,lo8(1)
 998 02f6 8083      		st Z,r24
 999 02f8 0895      		ret
 1000               	.LVL68:
 1001               	.L53:
 1002               		.loc 3 72 26 view .LVU334
 1003               	.LBE59:
  73:main.c        ****         }
  74:main.c        ****     }
  75:main.c        ****     else if ((RX_raw>=0) && (RX_raw<201))
 1004               		.loc 3 75 10 is_stmt 1 view .LVU335
 1005               		.loc 3 75 13 is_stmt 0 view .LVU336
 1006 02fa E93C      		cpi r30,lo8(-55)
 1007 02fc 00F4      		brsh .L52
 1008               	.LBB60:
  76:main.c        ****     {
  77:main.c        ****         uint8_t r_temp1=(RX_ad1-201);
 1009               		.loc 3 77 9 is_stmt 1 view .LVU337
 1010               		.loc 3 77 17 is_stmt 0 view .LVU338
 1011 02fe A091 0000 		lds r26,RX_ad1
 1012 0302 A95C      		subi r26,lo8(-(55))
 1013               	.LVL69:
  78:main.c        ****         if (r_temp1<16)
 1014               		.loc 3 78 9 is_stmt 1 view .LVU339
 1015               		.loc 3 78 12 is_stmt 0 view .LVU340
 1016 0304 A031      		cpi r26,lo8(16)
 1017 0306 00F4      		brsh .L52
  79:main.c        ****         {
  80:main.c        ****             RX[r_temp1]=RX_raw;
 1018               		.loc 3 80 13 is_stmt 1 view .LVU341
 1019               		.loc 3 80 15 is_stmt 0 view .LVU342
 1020 0308 B0E0      		ldi r27,0
 1021               		.loc 3 80 24 view .LVU343
 1022 030a A050      		subi r26,lo8(-(RX))
 1023 030c B040      		sbci r27,hi8(-(RX))
 1024               	.LVL70:
 1025               		.loc 3 80 24 view .LVU344
 1026 030e EC93      		st X,r30
 1027               	.LVL71:
 1028               	.L52:
 1029               	/* epilogue start */
 1030               		.loc 3 80 24 view .LVU345
 1031               	.LBE60:
  81:main.c        ****         }
  82:main.c        ****     }
  83:main.c        **** }
 1032               		.loc 3 83 1 view .LVU346
 1033 0310 0895      		ret
 1034               		.cfi_endproc
 1035               	.LFE23:
 1037               	.global	__vector_54
 1039               	__vector_54:
 1040               	.LFB24:
  84:main.c        **** 
  85:main.c        **** ISR(USART3_RX_vect)
  86:main.c        **** {
 1041               		.loc 3 86 1 is_stmt 1 view -0
 1042               		.cfi_startproc
 1043 0312 1F92      		push r1
 1044               	.LCFI6:
 1045               		.cfi_def_cfa_offset 4
 1046               		.cfi_offset 1, -3
 1047 0314 0F92      		push r0
 1048               	.LCFI7:
 1049               		.cfi_def_cfa_offset 5
 1050               		.cfi_offset 0, -4
 1051 0316 0FB6      		in r0,__SREG__
 1052 0318 0F92      		push r0
 1053 031a 1124      		clr __zero_reg__
 1054 031c 0BB6      		in r0,__RAMPZ__
 1055 031e 0F92      		push r0
 1056 0320 2F93      		push r18
 1057               	.LCFI8:
 1058               		.cfi_def_cfa_offset 6
 1059               		.cfi_offset 18, -5
 1060 0322 3F93      		push r19
 1061               	.LCFI9:
 1062               		.cfi_def_cfa_offset 7
 1063               		.cfi_offset 19, -6
 1064 0324 4F93      		push r20
 1065               	.LCFI10:
 1066               		.cfi_def_cfa_offset 8
 1067               		.cfi_offset 20, -7
 1068 0326 5F93      		push r21
 1069               	.LCFI11:
 1070               		.cfi_def_cfa_offset 9
 1071               		.cfi_offset 21, -8
 1072 0328 6F93      		push r22
 1073               	.LCFI12:
 1074               		.cfi_def_cfa_offset 10
 1075               		.cfi_offset 22, -9
 1076 032a 7F93      		push r23
 1077               	.LCFI13:
 1078               		.cfi_def_cfa_offset 11
 1079               		.cfi_offset 23, -10
 1080 032c 8F93      		push r24
 1081               	.LCFI14:
 1082               		.cfi_def_cfa_offset 12
 1083               		.cfi_offset 24, -11
 1084 032e 9F93      		push r25
 1085               	.LCFI15:
 1086               		.cfi_def_cfa_offset 13
 1087               		.cfi_offset 25, -12
 1088 0330 AF93      		push r26
 1089               	.LCFI16:
 1090               		.cfi_def_cfa_offset 14
 1091               		.cfi_offset 26, -13
 1092 0332 BF93      		push r27
 1093               	.LCFI17:
 1094               		.cfi_def_cfa_offset 15
 1095               		.cfi_offset 27, -14
 1096 0334 EF93      		push r30
 1097               	.LCFI18:
 1098               		.cfi_def_cfa_offset 16
 1099               		.cfi_offset 30, -15
 1100 0336 FF93      		push r31
 1101               	.LCFI19:
 1102               		.cfi_def_cfa_offset 17
 1103               		.cfi_offset 31, -16
 1104               	/* prologue: Signal */
 1105               	/* frame size = 0 */
 1106               	/* stack size = 16 */
 1107               	.L__stack_usage = 16
  87:main.c        ****     RX_raw=UDR3;
 1108               		.loc 3 87 5 view .LVU348
 1109               		.loc 3 87 12 is_stmt 0 view .LVU349
 1110 0338 8091 3601 		lds r24,310
 1111               		.loc 3 87 11 view .LVU350
 1112 033c 8093 0000 		sts RX_raw,r24
  88:main.c        ****     receive();
 1113               		.loc 3 88 5 is_stmt 1 view .LVU351
 1114 0340 0E94 0000 		call receive
 1115               	.LVL72:
 1116               	/* epilogue start */
  89:main.c        **** }
 1117               		.loc 3 89 1 is_stmt 0 view .LVU352
 1118 0344 FF91      		pop r31
 1119 0346 EF91      		pop r30
 1120 0348 BF91      		pop r27
 1121 034a AF91      		pop r26
 1122 034c 9F91      		pop r25
 1123 034e 8F91      		pop r24
 1124 0350 7F91      		pop r23
 1125 0352 6F91      		pop r22
 1126 0354 5F91      		pop r21
 1127 0356 4F91      		pop r20
 1128 0358 3F91      		pop r19
 1129 035a 2F91      		pop r18
 1130 035c 0F90      		pop r0
 1131 035e 0BBE      		out __RAMPZ__,r0
 1132 0360 0F90      		pop r0
 1133 0362 0FBE      		out __SREG__,r0
 1134 0364 0F90      		pop r0
 1135 0366 1F90      		pop r1
 1136 0368 1895      		reti
 1137               		.cfi_endproc
 1138               	.LFE24:
 1140               	.global	timer3_init
 1142               	timer3_init:
 1143               	.LFB25:
  90:main.c        **** 
  91:main.c        **** void timer3_init(void)
  92:main.c        **** {
 1144               		.loc 3 92 1 is_stmt 1 view -0
 1145               		.cfi_startproc
 1146               	/* prologue: function */
 1147               	/* frame size = 0 */
 1148               	/* stack size = 0 */
 1149               	.L__stack_usage = 0
  93:main.c        ****     TCCR3A = 0x00;
 1150               		.loc 3 93 5 view .LVU354
 1151               		.loc 3 93 12 is_stmt 0 view .LVU355
 1152 036a 1092 9000 		sts 144,__zero_reg__
  94:main.c        ****     TCCR3B = (1<<CS30);
 1153               		.loc 3 94 5 is_stmt 1 view .LVU356
 1154               		.loc 3 94 12 is_stmt 0 view .LVU357
 1155 036e 81E0      		ldi r24,lo8(1)
 1156 0370 8093 9100 		sts 145,r24
  95:main.c        ****     TCNT3 = 0;
 1157               		.loc 3 95 5 is_stmt 1 view .LVU358
 1158               		.loc 3 95 11 is_stmt 0 view .LVU359
 1159 0374 1092 9500 		sts 148+1,__zero_reg__
 1160 0378 1092 9400 		sts 148,__zero_reg__
 1161               	/* epilogue start */
  96:main.c        **** }
 1162               		.loc 3 96 1 view .LVU360
 1163 037c 0895      		ret
 1164               		.cfi_endproc
 1165               	.LFE25:
 1167               	.global	ps2_values
 1169               	ps2_values:
 1170               	.LFB22:
  28:main.c        ****     if (butt[10]==1)//up
 1171               		.loc 3 28 1 is_stmt 1 view -0
 1172               		.cfi_startproc
 1173               	/* prologue: function */
 1174               	/* frame size = 0 */
 1175               	/* stack size = 0 */
 1176               	.L__stack_usage = 0
  29:main.c        ****     {
 1177               		.loc 3 29 5 view .LVU362
  29:main.c        ****     {
 1178               		.loc 3 29 8 is_stmt 0 view .LVU363
 1179 037e 9091 0000 		lds r25,butt+10
 1180 0382 9130      		cpi r25,lo8(1)
 1181 0384 01F4      		brne .L60
  31:main.c        ****         TCCR3A = 0x00;
 1182               		.loc 3 31 9 is_stmt 1 view .LVU364
  31:main.c        ****         TCCR3A = 0x00;
 1183               		.loc 3 31 21 is_stmt 0 view .LVU365
 1184 0386 8091 0000 		lds r24,actuate_out
 1185 038a 8927      		eor r24,r25
 1186 038c 8093 0000 		sts actuate_out,r24
  32:main.c        ****         TCCR3B = 0x00;
 1187               		.loc 3 32 9 is_stmt 1 view .LVU366
  32:main.c        ****         TCCR3B = 0x00;
 1188               		.loc 3 32 16 is_stmt 0 view .LVU367
 1189 0390 1092 9000 		sts 144,__zero_reg__
  33:main.c        ****         TCNT3 = 0;
 1190               		.loc 3 33 9 is_stmt 1 view .LVU368
  33:main.c        ****         TCNT3 = 0;
 1191               		.loc 3 33 16 is_stmt 0 view .LVU369
 1192 0394 1092 9100 		sts 145,__zero_reg__
  34:main.c        ****         butt[10] = 0;
 1193               		.loc 3 34 9 is_stmt 1 view .LVU370
  34:main.c        ****         butt[10] = 0;
 1194               		.loc 3 34 15 is_stmt 0 view .LVU371
 1195 0398 1092 9500 		sts 148+1,__zero_reg__
 1196 039c 1092 9400 		sts 148,__zero_reg__
  35:main.c        ****     }
 1197               		.loc 3 35 9 is_stmt 1 view .LVU372
  35:main.c        ****     }
 1198               		.loc 3 35 18 is_stmt 0 view .LVU373
 1199 03a0 1092 0000 		sts butt+10,__zero_reg__
 1200               	.L60:
  37:main.c        ****     {
 1201               		.loc 3 37 5 is_stmt 1 view .LVU374
  37:main.c        ****     {
 1202               		.loc 3 37 8 is_stmt 0 view .LVU375
 1203 03a4 9091 0000 		lds r25,butt+11
 1204 03a8 9130      		cpi r25,lo8(1)
 1205 03aa 01F4      		brne .L61
 1206               	.LBB61:
  39:main.c        ****         timer3_init();
 1207               		.loc 3 39 9 is_stmt 1 view .LVU376
  39:main.c        ****         timer3_init();
 1208               		.loc 3 39 20 is_stmt 0 view .LVU377
 1209 03ac 8091 0000 		lds r24,actuate_in
 1210 03b0 8927      		eor r24,r25
 1211 03b2 8093 0000 		sts actuate_in,r24
  40:main.c        ****         butt[11] = 0;
 1212               		.loc 3 40 9 is_stmt 1 view .LVU378
 1213 03b6 0E94 0000 		call timer3_init
 1214               	.LVL73:
  41:main.c        ****     }
 1215               		.loc 3 41 9 view .LVU379
  41:main.c        ****     }
 1216               		.loc 3 41 18 is_stmt 0 view .LVU380
 1217 03ba 1092 0000 		sts butt+11,__zero_reg__
 1218               	.L61:
 1219               	.LBE61:
  43:main.c        ****     {
 1220               		.loc 3 43 5 is_stmt 1 view .LVU381
  43:main.c        ****     {
 1221               		.loc 3 43 8 is_stmt 0 view .LVU382
 1222 03be 9091 0000 		lds r25,butt+12
 1223 03c2 9130      		cpi r25,lo8(1)
 1224 03c4 01F4      		brne .L62
  45:main.c        ****         TCCR3A = 0x00;
 1225               		.loc 3 45 9 is_stmt 1 view .LVU383
  45:main.c        ****         TCCR3A = 0x00;
 1226               		.loc 3 45 21 is_stmt 0 view .LVU384
 1227 03c6 8091 0000 		lds r24,actuate_out
 1228 03ca 8927      		eor r24,r25
 1229 03cc 8093 0000 		sts actuate_out,r24
  46:main.c        ****         TCCR3B = 0x00;
 1230               		.loc 3 46 9 is_stmt 1 view .LVU385
  46:main.c        ****         TCCR3B = 0x00;
 1231               		.loc 3 46 16 is_stmt 0 view .LVU386
 1232 03d0 1092 9000 		sts 144,__zero_reg__
  47:main.c        ****         TCNT3 = 0;
 1233               		.loc 3 47 9 is_stmt 1 view .LVU387
  47:main.c        ****         TCNT3 = 0;
 1234               		.loc 3 47 16 is_stmt 0 view .LVU388
 1235 03d4 1092 9100 		sts 145,__zero_reg__
  48:main.c        ****         butt[12] = 0;
 1236               		.loc 3 48 9 is_stmt 1 view .LVU389
  48:main.c        ****         butt[12] = 0;
 1237               		.loc 3 48 15 is_stmt 0 view .LVU390
 1238 03d8 1092 9500 		sts 148+1,__zero_reg__
 1239 03dc 1092 9400 		sts 148,__zero_reg__
  49:main.c        ****     }
 1240               		.loc 3 49 9 is_stmt 1 view .LVU391
  49:main.c        ****     }
 1241               		.loc 3 49 18 is_stmt 0 view .LVU392
 1242 03e0 1092 0000 		sts butt+12,__zero_reg__
 1243               	.L62:
  51:main.c        ****     {
 1244               		.loc 3 51 5 is_stmt 1 view .LVU393
  51:main.c        ****     {
 1245               		.loc 3 51 8 is_stmt 0 view .LVU394
 1246 03e4 9091 0000 		lds r25,butt+13
 1247 03e8 9130      		cpi r25,lo8(1)
 1248 03ea 01F4      		brne .L63
 1249               	.LBB62:
  53:main.c        ****         timer3_init();
 1250               		.loc 3 53 9 is_stmt 1 view .LVU395
  53:main.c        ****         timer3_init();
 1251               		.loc 3 53 20 is_stmt 0 view .LVU396
 1252 03ec 8091 0000 		lds r24,actuate_in
 1253 03f0 8927      		eor r24,r25
 1254 03f2 8093 0000 		sts actuate_in,r24
  54:main.c        ****         butt[13] = 0;
 1255               		.loc 3 54 9 is_stmt 1 view .LVU397
 1256 03f6 0E94 0000 		call timer3_init
 1257               	.LVL74:
  55:main.c        ****     }
 1258               		.loc 3 55 9 view .LVU398
  55:main.c        ****     }
 1259               		.loc 3 55 18 is_stmt 0 view .LVU399
 1260 03fa 1092 0000 		sts butt+13,__zero_reg__
 1261               	.L63:
 1262               	.LBE62:
  57:main.c        ****     {
 1263               		.loc 3 57 5 is_stmt 1 view .LVU400
  57:main.c        ****     {
 1264               		.loc 3 57 8 is_stmt 0 view .LVU401
 1265 03fe 9091 0000 		lds r25,butt+14
 1266 0402 9130      		cpi r25,lo8(1)
 1267 0404 01F4      		brne .L59
  59:main.c        ****         butt[14] = 0;
 1268               		.loc 3 59 9 is_stmt 1 view .LVU402
  59:main.c        ****         butt[14] = 0;
 1269               		.loc 3 59 15 is_stmt 0 view .LVU403
 1270 0406 8091 0000 		lds r24,start
 1271 040a 8927      		eor r24,r25
 1272 040c 8093 0000 		sts start,r24
  60:main.c        ****     }
 1273               		.loc 3 60 9 is_stmt 1 view .LVU404
  60:main.c        ****     }
 1274               		.loc 3 60 18 is_stmt 0 view .LVU405
 1275 0410 1092 0000 		sts butt+14,__zero_reg__
 1276               	.L59:
 1277               	/* epilogue start */
  62:main.c        **** 
 1278               		.loc 3 62 1 view .LVU406
 1279 0414 0895      		ret
 1280               		.cfi_endproc
 1281               	.LFE22:
 1283               	.global	__fixunssfsi
 1284               	.global	__floatunsisf
 1285               	.global	__divsf3
 1286               	.global	__mulsf3
 1287               		.section	.text.startup,"ax",@progbits
 1288               	.global	main
 1290               	main:
 1291               	.LFB26:
  97:main.c        **** 
  98:main.c        **** int main()
  99:main.c        **** {
 1292               		.loc 3 99 1 is_stmt 1 view -0
 1293               		.cfi_startproc
 1294               	/* prologue: function */
 1295               	/* frame size = 0 */
 1296               	/* stack size = 0 */
 1297               	.L__stack_usage = 0
 100:main.c        ****     init_ports();
 1298               		.loc 3 100 5 view .LVU408
 1299 0000 0E94 0000 		call init_ports
 1300               	.LVL75:
 101:main.c        ****     lcd_init();
 1301               		.loc 3 101 5 view .LVU409
 1302 0004 0E94 0000 		call lcd_init
 1303               	.LVL76:
 102:main.c        ****     timer3_init();
 1304               		.loc 3 102 5 view .LVU410
 1305 0008 0E94 0000 		call timer3_init
 1306               	.LVL77:
 103:main.c        ****     bluetooth_init();
 1307               		.loc 3 103 5 view .LVU411
 1308 000c 0E94 0000 		call bluetooth_init
 1309               	.LVL78:
 104:main.c        ****     usart_init();
 1310               		.loc 3 104 5 view .LVU412
 1311 0010 0E94 0000 		call usart_init
 1312               	.LVL79:
 105:main.c        ****     DDRD = 0x00;
 1313               		.loc 3 105 5 view .LVU413
 1314               		.loc 3 105 10 is_stmt 0 view .LVU414
 1315 0014 1AB8      		out 0xa,__zero_reg__
 106:main.c        ****     DDRA = 0xFF;
 1316               		.loc 3 106 5 is_stmt 1 view .LVU415
 1317               		.loc 3 106 10 is_stmt 0 view .LVU416
 1318 0016 8FEF      		ldi r24,lo8(-1)
 1319 0018 81B9      		out 0x1,r24
 107:main.c        ****     
 108:main.c        ****     lcd_print(1,2,result,1);
 1320               		.loc 3 108 5 is_stmt 1 view .LVU417
 1321 001a 6091 0000 		lds r22,result
 1322 001e 7091 0000 		lds r23,result+1
 1323 0022 8091 0000 		lds r24,result+2
 1324 0026 9091 0000 		lds r25,result+3
 1325 002a 0E94 0000 		call __fixunssfsi
 1326               	.LVL80:
 1327 002e 21E0      		ldi r18,lo8(1)
 1328 0030 30E0      		ldi r19,0
 1329 0032 AB01      		movw r20,r22
 1330 0034 62E0      		ldi r22,lo8(2)
 1331 0036 81E0      		ldi r24,lo8(1)
 1332 0038 0E94 0000 		call lcd_print
 1333               	.LVL81:
 1334               	.LBB63:
 109:main.c        ****     while(1)
 110:main.c        ****     {
 111:main.c        ****         PORTA = 0x02;
 1335               		.loc 3 111 15 is_stmt 0 view .LVU418
 1336 003c C2E0      		ldi r28,lo8(2)
 1337               	.L67:
 1338               	.LBE63:
 109:main.c        ****     while(1)
 1339               		.loc 3 109 5 is_stmt 1 view .LVU419
 1340               	.LBB68:
 1341               		.loc 3 111 9 view .LVU420
 1342               		.loc 3 111 15 is_stmt 0 view .LVU421
 1343 003e C2B9      		out 0x2,r28
 112:main.c        ****         _delay_ms(2000);
 1344               		.loc 3 112 9 is_stmt 1 view .LVU422
 1345               	.LVL82:
 1346               	.LBB64:
 1347               	.LBI64:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 1348               		.loc 2 166 1 view .LVU423
 1349               	.LBB65:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1350               		.loc 2 168 2 view .LVU424
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1351               		.loc 2 172 2 view .LVU425
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1352               		.loc 2 173 2 view .LVU426
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 1353               		.loc 2 174 2 view .LVU427
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 1354               		.loc 2 184 3 view .LVU428
 1355               		.loc 2 187 2 view .LVU429
 1356 0040 2FEF      		ldi r18,lo8(5898239)
 1357 0042 8FEF      		ldi r24,hi8(5898239)
 1358 0044 99E5      		ldi r25,hlo8(5898239)
 1359 0046 2150      	1:	subi r18,1
 1360 0048 8040      		sbci r24,0
 1361 004a 9040      		sbci r25,0
 1362 004c 01F4      		brne 1b
 1363 004e 00C0      		rjmp .
 1364 0050 0000      		nop
 1365               	.LVL83:
 1366               		.loc 2 187 2 is_stmt 0 view .LVU430
 1367               	.LBE65:
 1368               	.LBE64:
 113:main.c        ****         PORTA = 0x00;
 1369               		.loc 3 113 9 is_stmt 1 view .LVU431
 1370               		.loc 3 113 15 is_stmt 0 view .LVU432
 1371 0052 12B8      		out 0x2,__zero_reg__
 114:main.c        ****         timer3_init();
 1372               		.loc 3 114 9 is_stmt 1 view .LVU433
 1373 0054 0E94 0000 		call timer3_init
 1374               	.LVL84:
 115:main.c        ****         while(!(PIND & (1<<0)))
 1375               		.loc 3 115 9 view .LVU434
 1376               	.L66:
 116:main.c        ****         {
 117:main.c        ****         }
 1377               		.loc 3 117 9 discriminator 1 view .LVU435
 115:main.c        ****         while(!(PIND & (1<<0)))
 1378               		.loc 3 115 14 is_stmt 0 discriminator 1 view .LVU436
 1379 0058 489B      		sbis 0x9,0
 1380 005a 00C0      		rjmp .L66
 118:main.c        ****         result = TCNT3;
 1381               		.loc 3 118 9 is_stmt 1 view .LVU437
 1382               		.loc 3 118 18 is_stmt 0 view .LVU438
 1383 005c 6091 9400 		lds r22,148
 1384 0060 7091 9500 		lds r23,148+1
 1385               		.loc 3 118 16 view .LVU439
 1386 0064 90E0      		ldi r25,0
 1387 0066 80E0      		ldi r24,0
 1388 0068 0E94 0000 		call __floatunsisf
 1389               	.LVL85:
 1390 006c 6093 0000 		sts result,r22
 1391 0070 7093 0000 		sts result+1,r23
 1392 0074 8093 0000 		sts result+2,r24
 1393 0078 9093 0000 		sts result+3,r25
 119:main.c        ****         float time = result/F_CPU;
 1394               		.loc 3 119 9 is_stmt 1 view .LVU440
 1395               		.loc 3 119 15 is_stmt 0 view .LVU441
 1396 007c 20E0      		ldi r18,0
 1397 007e 30E0      		ldi r19,0
 1398 0080 41E6      		ldi r20,lo8(97)
 1399 0082 5BE4      		ldi r21,lo8(75)
 1400 0084 0E94 0000 		call __divsf3
 1401               	.LVL86:
 120:main.c        ****         time = time*1000000;
 1402               		.loc 3 120 9 is_stmt 1 view .LVU442
 121:main.c        ****         lcd_print(1,2,time,4);
 1403               		.loc 3 121 9 view .LVU443
 120:main.c        ****         time = time*1000000;
 1404               		.loc 3 120 14 is_stmt 0 view .LVU444
 1405 0088 20E0      		ldi r18,0
 1406 008a 34E2      		ldi r19,lo8(36)
 1407 008c 44E7      		ldi r20,lo8(116)
 1408 008e 59E4      		ldi r21,lo8(73)
 1409 0090 0E94 0000 		call __mulsf3
 1410               	.LVL87:
 1411               		.loc 3 121 9 view .LVU445
 1412 0094 0E94 0000 		call __fixunssfsi
 1413               	.LVL88:
 1414 0098 24E0      		ldi r18,lo8(4)
 1415 009a 30E0      		ldi r19,0
 1416 009c AB01      		movw r20,r22
 1417 009e 62E0      		ldi r22,lo8(2)
 1418 00a0 81E0      		ldi r24,lo8(1)
 1419 00a2 0E94 0000 		call lcd_print
 1420               	.LVL89:
 122:main.c        ****         _delay_ms(2000);
 1421               		.loc 3 122 9 is_stmt 1 view .LVU446
 1422               	.LBB66:
 1423               	.LBI66:
 166:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** {
 1424               		.loc 2 166 1 view .LVU447
 1425               	.LBB67:
 168:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1426               		.loc 2 168 2 view .LVU448
 172:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1427               		.loc 2 172 2 view .LVU449
 173:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1428               		.loc 2 173 2 view .LVU450
 174:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 
 1429               		.loc 2 174 2 view .LVU451
 184:/usr/local/Cellar/avr-gcc/8.2.0/avr/include/util/delay.h **** 	#endif
 1430               		.loc 2 184 3 view .LVU452
 1431               		.loc 2 187 2 view .LVU453
 1432 00a6 2FEF      		ldi r18,lo8(5898239)
 1433 00a8 8FEF      		ldi r24,hi8(5898239)
 1434 00aa 99E5      		ldi r25,hlo8(5898239)
 1435 00ac 2150      	1:	subi r18,1
 1436 00ae 8040      		sbci r24,0
 1437 00b0 9040      		sbci r25,0
 1438 00b2 01F4      		brne 1b
 1439 00b4 00C0      		rjmp .
 1440 00b6 0000      		nop
 1441 00b8 00C0      		rjmp .L67
 1442               	.LBE67:
 1443               	.LBE66:
 1444               	.LBE68:
 1445               		.cfi_endproc
 1446               	.LFE26:
 1448               		.comm	result,4,1
 1449               		.comm	RX,4,1
 1450               		.comm	RX_ad1,1,1
 1451               		.comm	RX_ad,4,1
 1452               		.comm	butt,16,1
 1453               		.comm	RX_raw,1,1
 1454               	.global	start
 1455               		.section .bss
 1458               	start:
 1459 0000 00        		.zero	1
 1460               	.global	actuate_in
 1463               	actuate_in:
 1464 0001 00        		.zero	1
 1465               	.global	actuate_out
 1468               	actuate_out:
 1469 0002 00        		.zero	1
 1470               		.comm	million,2,1
 1471               		.comm	thousand,2,1
 1472               		.comm	hundred,2,1
 1473               		.comm	tens,2,1
 1474               		.comm	unit,2,1
 1475               		.comm	temp,2,1
 1476               		.text
 1477               	.Letext0:
 1478               		.file 4 "/usr/local/Cellar/avr-gcc/8.2.0/avr/include/stdint.h"
 1479               		.file 5 "/usr/local/Cellar/avr-gcc/8.2.0/lib/avr-gcc/8/gcc/avr/8.2.0/include/stddef.h"
 1480               		.file 6 "/usr/local/Cellar/avr-gcc/8.2.0/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:4      *ABS*:000000000000003f __SREG__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:13     .text:0000000000000000 init_ports
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:43     .text:000000000000000e lcd_set_4bit
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:278    .text:0000000000000094 lcd_wr_command
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:392    .text:00000000000000de lcd_init
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:448    .text:000000000000010a lcd_wr_char
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:562    .text:0000000000000154 lcd_home
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:579    .text:000000000000015a lcd_string
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:627    .text:0000000000000172 lcd_cursor
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:674    .text:000000000000019a lcd_print
                            *COM*:0000000000000002 million
                            *COM*:0000000000000002 temp
                            *COM*:0000000000000002 thousand
                            *COM*:0000000000000002 hundred
                            *COM*:0000000000000002 tens
                            *COM*:0000000000000002 unit
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:899    .text:00000000000002aa bluetooth_init
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:930    .text:00000000000002c0 usart_init
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:961    .text:00000000000002d8 receive
                            *COM*:0000000000000001 RX_raw
                            *COM*:0000000000000001 RX_ad1
                            *COM*:0000000000000010 butt
                            *COM*:0000000000000004 RX
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:1039   .text:0000000000000312 __vector_54
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:1142   .text:000000000000036a timer3_init
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:1169   .text:000000000000037e ps2_values
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:1468   .bss:0000000000000002 actuate_out
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:1463   .bss:0000000000000001 actuate_in
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:1458   .bss:0000000000000000 start
/var/folders/8l/7fwvwj4x3gd5t_mcstd596tm0000gn/T//ccjZM5NJ.s:1290   .text.startup:0000000000000000 main
                            *COM*:0000000000000004 result
                            *COM*:0000000000000004 RX_ad

UNDEFINED SYMBOLS
__udivmodhi4
__fixunssfsi
__floatunsisf
__divsf3
__mulsf3
__do_clear_bss
